<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>SWI-Prolog 7.6.2 Reference Manual: Section 4.20</title><link rel="home" href="index.html">
<link rel="contents" href="Contents.html">
<link rel="index" href="DocIndex.html">
<link rel="summary" href="summary.html">
<link rel="previous" href="chario.html">
<link rel="next" href="manipterm.html">

<style type="text/css">

/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

dt.multidef
{ background-color: #c8ffc7;
}

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #202020;
}

div.caption
{ width: 80%;
margin: auto;
text-align:center;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}

/* Lists */

dl.latex
{ margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.latex dl.latex dd.defbody
{ margin-bottom: 0.5ex;
}

/* PlDoc Tags */

dl.tags
{ font-size: 90%;
margin-left: 5ex;
margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.tags dt
{ margin-left: 0pt;
font-weight: bold;
}

dl.tags dd
{ margin-left: 3ex;
}

td.param
{ font-style: italic;
font-weight: bold;
}

/* Index */

dt.index-sep
{ font-weight: bold;
font-size: +1;
margin-top: 1ex;
}
</style>
</head>
<body style="background:white">
<div class="navigate"><a class="nav" href="index.html"><img src="home.gif" alt="Home"></a>
<a class="nav" href="Contents.html"><img src="index.gif" alt="Contents"></a>
<a class="nav" href="DocIndex.html"><img src="yellow_pages.gif" alt="Index"></a>
<a class="nav" href="summary.html"><img src="info.gif" alt="Summary"></a>
<a class="nav" href="chario.html"><img src="prev.gif" alt="Previous"></a>
<a class="nav" href="manipterm.html"><img src="next.gif" alt="Next"></a>
</div>
<h2 id="sec:termrw"><a name="sec:4.20"><span class="sec-nr">4.20</span> <span class="sec-title">Term 
reading and writing</span></a></h2>

<a name="sec:termrw"></a>

<p>This section describes the basic term reading and writing predicates. 
The predicates <a name="idx:format12:1114"></a><a class="pred" href="format.html#format/1">format/[1,2]</a> 
and <a name="idx:writef2:1115"></a><a class="pred" href="format.html#writef/2">writef/2</a> 
provide formatted output. Writing to Prolog data structures such as 
atoms or code-lists is supported by <a name="idx:withoutputto2:1116"></a><a class="pred" href="IO.html#with_output_to/2">with_output_to/2</a> 
and <a name="idx:format3:1117"></a><a class="pred" href="format.html#format/3">format/3</a>.

<p>Reading is sensitive to the Prolog flag <a class="flag" href="flags.html#flag:character_escapes">character_escapes</a>, 
which controls the interpretation of the <code><code>\</code></code> 
character in quoted atoms and strings.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="write_term/2"><strong>write_term</strong>(<var>+Term, 
+Options</var>)</a></dt>
<dd class="defbody">
The predicate <a name="idx:writeterm2:1118"></a><a class="pred" href="termrw.html#write_term/2">write_term/2</a> 
is the generic form of all Prolog term-write predicates. Valid options 
are:

<dl class="latex">
<dt><strong>attributes</strong>(<var>Atom</var>)</dt>
<dd class="defbody">
Define how attributed variables (see <a class="sec" href="attvar.html">section 
7.1</a>) are written. The default is determined by the Prolog flag <a class="flag" href="flags.html#flag:write_attributes">write_attributes</a>. 
Defined values are <code>ignore</code> (ignore the attribute), <code>dots</code> 
(write the attributes as <code>{...}</code>), <code>write</code> (simply 
hand the attributes recursively to <a name="idx:writeterm2:1119"></a><a class="pred" href="termrw.html#write_term/2">write_term/2</a>) 
and <code>portray</code> (hand the attributes to <a name="idx:attrportrayhook2:1120"></a><a class="pred" href="attvar.html#attr_portray_hook/2">attr_portray_hook/2</a>).</dd>
<dt><strong>back_quotes</strong>(<var>Atom</var>)</dt>
<dd class="defbody">
Fulfills the same role as the <a class="flag" href="flags.html#flag:back_quotes">back_quotes</a> 
prolog flag. Notably, the value <code>string</code> causes string 
objects to be printed between back quotes and <code>symbol_char</code> 
causes the backquote to be printed unquoted. In all other cases the 
backquote is printed as a quoted atom.</dd>
<dt><strong>brace_terms</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>true</code> (default), write <code>{}(X)</code> as <code>{X}</code>. 
See also
<code>dotlists</code> and <code>ignore_ops</code>.</dd>
<dt><strong>blobs</strong>(<var>Atom</var>)</dt>
<dd class="defbody">
Define how non-text blobs are handled. By default, this is left to the 
write handler specified with the blob type. Using <code>portray</code>,
<a name="idx:portray1:1121"></a><a class="pred" href="termrw.html#portray/1">portray/1</a> 
is called for each blob encountered. See <a class="sec" href="foreigninclude.html">section 
11.4.7</a>.</dd>
<dt><strong>character_escapes</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>true</code> and <code>quoted(true)</code> is active, special 
characters in quoted atoms and strings are emitted as ISO escape 
sequences. Default is taken from the reference module (see below).</dd>
<dt><strong>cycles</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>true</code> (default), cyclic terms are written as
<code>@(Template, Substitutions)</code>, where <var>Substitutions</var> 
is a list
<var>Var</var> = <var>Value</var>. If <code>cycles</code> is <code>false</code>,
<code>max_depth</code> is not given, and <var>Term</var> is cyclic, <a name="idx:writeterm2:1122"></a><a class="pred" href="termrw.html#write_term/2">write_term/2</a> 
raises a <code>domain_error</code>.<sup class="fn">92<span class="fn-text">The 
cycles option and the cyclic term representation using the @-term are 
copied from SICStus Prolog. However, the default in SICStus is set to <code>false</code> 
and SICStus writes an infinite term if not protected by, e.g., the <code>depth_limit</code> 
option.</span></sup> See also the <code>cycles</code> option in
<a name="idx:readterm2:1123"></a><a class="pred" href="termrw.html#read_term/2">read_term/2</a>.</dd>
<dt><strong>dotlists</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>true</code> (default <code>false</code>), write lists using the 
dotted term notation rather than the list notation.<sup class="fn">93<span class="fn-text">Copied 
from ECLiPSe.</span></sup> Note that as of version&nbsp;7, the list 
constructor is
<code>'[|]'</code>. Using <code>dotlists(true)</code>, <a name="idx:writeterm2:1124"></a><a class="pred" href="termrw.html#write_term/2">write_term/2</a> 
writes a list using `.' as constructor. This is intended for 
communication with programs such as other Prolog systems, that rely on 
this notation.</dd>
<dt><strong>fullstop</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>true</code> (default <code>false</code>), add a fullstop token 
to the output. The dot is preceeded by a space if needed and followed by 
a space (default) or newline if the <code>nl(true)</code> option is also 
given.<sup class="fn">94<span class="fn-text">Compatible with http://eclipseclp.org/doc/bips/kernel/ioterm/write_term-3.htmlECLiPSe</span></sup></dd>
<dt><strong>ignore_ops</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>true</code>, the generic term representation (&lt;<var>functor</var>&gt;(&lt;<var>args</var>&gt; 
... )) will be used for all terms. Otherwise (default), operators will 
be used where appropriate.<sup class="fn">95<span class="fn-text">In 
traditional systems this flag also stops the syntactic sugar notation 
for lists and brace terms. In SWI-Prolog, these are controlled by the 
separate options <code>dotlists</code> and <code>brace_terms</code></span></sup>.</dd>
<dt><strong>max_depth</strong>(<var>Integer</var>)</dt>
<dd class="defbody">
If the term is nested deeper than <var>Integer</var>, print the 
remainder as ellipses ( ... ). A 0 (zero) value (default) imposes no 
depth limit. This option also delimits the number of printed items in a 
list. Example:

<pre class="code">
?- write_term(a(s(s(s(s(0)))), [a,b,c,d,e,f]),
              [max_depth(3)]).
a(s(s(...)), [a, b|...])
true.
</pre>

<p>Used by the top level and debugger to limit screen output. See also 
the Prolog flags <a class="flag" href="flags.html#flag:answer_write_options">answer_write_options</a> 
and
<a class="flag" href="flags.html#flag:debugger_write_options">debugger_write_options</a>.</dd>
<dt><strong>module</strong>(<var>Module</var>)</dt>
<dd class="defbody">
Define the reference module (default <code>user</code>). This defines 
the default value for the <a class="flag" href="flags.html#flag:character_escapes">character_escapes</a> 
option as well as the operator definitions to use. See also <a name="idx:op3:1125"></a><a class="pred" href="operators.html#op/3">op/3</a>.</dd>
<dt><strong>nl</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
Add a newline to the output. See also the <code>fullstop</code> option.</dd>
<dt><strong>numbervars</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>true</code>, terms of the format <code>$VAR(N)</code>, where <var>N</var> 
is a non-negative integer, will be written as a variable name. If <var>N</var> 
is an atom it is written without quotes. This extension allows for 
writing variables with user-provided names. The default is <code>false</code>. 
See also <a name="idx:numbervars3:1126"></a><a class="pred" href="manipterm.html#numbervars/3">numbervars/3</a> 
and the option <code>variable_names</code>.</dd>
<dt><strong>partial</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>true</code> (default <code>false</code>), do not reset the 
logic that inserts extra spaces that separate tokens where needed. This 
is intended to solve the problems with the code below. Calling <code>write_value(<code>.</code>)</code> 
writes <code>..</code>, which cannot be read. By adding <code>partial(true)</code> 
to the option list, it correctly emits <code>. .</code>. Similar 
problems appear when emitting operators using multiple calls to <a name="idx:writeterm3:1127"></a><a class="pred" href="termrw.html#write_term/3">write_term/3</a>.

<pre class="code">
write_value(Value) :-
        write_term(Value, [partial(true)]),
        write('.'), nl.
</pre>

</dd>
<dt><strong>portray</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
Same as <code>portrayed(Bool)</code>. Deprecated.</dd>
<dt><strong>portray_goal</strong>(<var>:Goal</var>)</dt>
<dd class="defbody">
Implies <code>portray(true)</code>, but calls <var>Goal</var> rather 
than the predefined hook <a name="idx:portray1:1128"></a><a class="pred" href="termrw.html#portray/1">portray/1</a>. <var>Goal</var> 
is called through <a name="idx:call3:1129"></a><span class="pred-ext">call/3</span>, 
where the first argument is <var>Goal</var>, the second is the term to 
be printed and the 3rd argument is the current write option list. The 
write option list is copied from the write_term call, but the list is 
guaranteed to hold an option <code>priority</code> that reflects the 
current priority.</dd>
<dt><strong>portrayed</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>true</code>, the hook <a name="idx:portray1:1130"></a><a class="pred" href="termrw.html#portray/1">portray/1</a> 
is called before printing a term that is not a variable. If <a name="idx:portray1:1131"></a><a class="pred" href="termrw.html#portray/1">portray/1</a> 
succeeds, the term is considered printed. See also <a name="idx:print1:1132"></a><a class="pred" href="termrw.html#print/1">print/1</a>. 
The default is <code>false</code>. This option is an extension to the 
ISO write_term options.</dd>
<dt><strong>priority</strong>(<var>Integer</var>)</dt>
<dd class="defbody">
An integer between 0 and 1200 representing the `context priority'. 
Default is 1200. Can be used to write partial terms appearing as the 
argument to an operator. For example:

<pre class="code">
        format('~w = ', [VarName]),
        write_term(Value, [quoted(true), priority(699)])
</pre>

</dd>
<dt><strong>quoted</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>true</code>, atoms and functors that need quotes will be 
quoted. The default is <code>false</code>.</dd>
<dt><strong>spacing</strong>(<var>+Spacing</var>)</dt>
<dd class="defbody">
Determines whether and where extra white space is added to enhance 
readability. The default is <code>standard</code>, adding only space 
where needed for proper tokenization by <a name="idx:readterm3:1133"></a><a class="pred" href="termrw.html#read_term/3">read_term/3</a>. 
Currently, the only other value is <code>next_argument</code>, adding a 
space after a comma used to separate arguments in a term or list.</dd>
<dt><strong>variable_names</strong>(<var>+List</var>)</dt>
<dd class="defbody">
Assign names to variables in <var>Term</var>. <var>List</var> is a list 
of terms
<var>Name</var> = <var>Var</var>, where <var>Name</var> is an atom that 
represents a valid Prolog variable name. Terms where <var>Var</var> is 
bound or is a variable that does not appear in <var>Term</var> are 
ignored. Raises an error if <var>List</var> is not a list, one of the 
members is not a term
<var>Name</var> = <var>Var</var>, <var>Name</var> is not an atom or
<var>Name</var> does not represent a valid Prolog variable name.

<p>The implementation binds the variables from <var>List</var> to a term
<code>'$VAR'</code>(<var>Name</var>). Like <a name="idx:writecanonical1:1134"></a><a class="pred" href="termrw.html#write_canonical/1">write_canonical/1</a>, 
terms that where already bound to <code>'$VAR'</code>(<var>X</var>) 
before <a name="idx:writeterm2:1135"></a><a class="pred" href="termrw.html#write_term/2">write_term/2</a> 
are printed normally, unless the option <code>numbervars(true)</code> is 
also provided. If the option <code>numbervars(true)</code> is used, the 
user is responsible for avoiding collisions between assigned names and 
numbered names. See also the <code>variable_names</code> option of
<a name="idx:readterm2:1136"></a><a class="pred" href="termrw.html#read_term/2">read_term/2</a>.

<p>Possible variable attributes (see <a class="sec" href="attvar.html">section 
7.1</a>) are ignored. In most cases one should use <a name="idx:copyterm3:1137"></a><a class="pred" href="attvar.html#copy_term/3">copy_term/3</a> 
to obtain a copy that is free of attributed variables and handle the 
associated constraints as appropriate for the use-case.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="write_term/3"><strong>write_term</strong>(<var>+Stream, 
+Term, +Options</var>)</a></dt>
<dd class="defbody">
As <a name="idx:writeterm2:1138"></a><a class="pred" href="termrw.html#write_term/2">write_term/2</a>, 
but output is sent to <var>Stream</var> rather than the current output.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a name="write_length/3"><strong>write_length</strong>(<var>+Term, 
-Length, +Options</var>)</a></dt>
<dd class="defbody">
True when <var>Length</var> is the number of characters emitted for
<var>write_term</var>Term, Options . In addition to valid options for
<a name="idx:writeterm2:1139"></a><a class="pred" href="termrw.html#write_term/2">write_term/2</a>, 
it processes the option:

<dl class="latex">
<dt><strong>max_length</strong>(<var>+MaxLength</var>)</dt>
<dd class="defbody">
If provided, fail if <var>Length</var> would be larger than <var>MaxLength</var>. 
The implementation ensures that the runtime is limited when computing 
the length of a huge term with a bounded maximum.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="write_canonical/1"><strong>write_canonical</strong>(<var>+Term</var>)</a></dt>
<dd class="defbody">
Write <var>Term</var> on the current output stream using standard 
parenthesised prefix notation (i.e., ignoring operator declarations). 
Atoms that need quotes are quoted. Terms written with this predicate can 
always be read back, regardless of current operator declarations. 
Equivalent to <a name="idx:writeterm2:1140"></a><a class="pred" href="termrw.html#write_term/2">write_term/2</a> 
using the options <code>ignore_ops</code>,
<code>quoted</code> and <code>numbervars</code> after <a name="idx:numbervars4:1141"></a><a class="pred" href="manipterm.html#numbervars/4">numbervars/4</a> 
using the
<code>singletons</code> option.

<p>Note that due to the use of <a name="idx:numbervars4:1142"></a><a class="pred" href="manipterm.html#numbervars/4">numbervars/4</a>, 
non-ground terms must be written using a <em>single</em> <a name="idx:writecanonical1:1143"></a><a class="pred" href="termrw.html#write_canonical/1">write_canonical/1</a> 
call. This used to be the case anyhow, as garbage collection between 
multiple calls to one of the write predicates can change the <code>_G</code>&lt;NNN&gt; 
identity of the variables.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="write_canonical/2"><strong>write_canonical</strong>(<var>+Stream, 
+Term</var>)</a></dt>
<dd class="defbody">
Write <var>Term</var> in canonical form on <var>Stream</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="write/1"><strong>write</strong>(<var>+Term</var>)</a></dt>
<dd class="defbody">
Write <var>Term</var> to the current output, using brackets and 
operators where appropriate.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="write/2"><strong>write</strong>(<var>+Stream, 
+Term</var>)</a></dt>
<dd class="defbody">
Write <var>Term</var> to <var>Stream</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="writeq/1"><strong>writeq</strong>(<var>+Term</var>)</a></dt>
<dd class="defbody">
Write <var>Term</var> to the current output, using brackets and 
operators where appropriate. Atoms that need quotes are quoted. Terms 
written with this predicate can be read back with <a name="idx:read1:1144"></a><a class="pred" href="termrw.html#read/1">read/1</a> 
provided the currently active operator declarations are identical.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="writeq/2"><strong>writeq</strong>(<var>+Stream, 
+Term</var>)</a></dt>
<dd class="defbody">
Write <var>Term</var> to <var>Stream</var>, inserting quotes.</dd>
<dt class="pubdef"><a name="writeln/1"><strong>writeln</strong>(<var>+Term</var>)</a></dt>
<dd class="defbody">
Equivalent to <code>write(Term), nl.</code>. The output stream is 
locked, which implies no output from other threads can appear between 
the term and newline.</dd>
<dt class="pubdef"><a name="writeln/2"><strong>writeln</strong>(<var>+Stream, 
+Term</var>)</a></dt>
<dd class="defbody">
Equivalent to <code>write(Stream, Term), nl(Stream).</code>. The output 
stream is locked, which implies no output from other threads can appear 
between the term and newline.</dd>
<dt class="pubdef"><a name="print/1"><strong>print</strong>(<var>+Term</var>)</a></dt>
<dd class="defbody">
Print a term for debugging purposes. The predicate <a name="idx:print1:1145"></a><a class="pred" href="termrw.html#print/1">print/1</a> 
acts as if defined as below.

<pre class="code">
print(Term) :-
    current_prolog_flag(print_write_options, Options), !,
    write_term(Term, Options).
print(Term) :-
    write_term(Term, [ portray(true),
                       numbervars(true),
                       quoted(true)
                     ]).
</pre>

<p>The <a name="idx:print1:1146"></a><a class="pred" href="termrw.html#print/1">print/1</a> 
predicate is used primarily through the <code>~p</code> escape sequence 
of <a name="idx:format2:1147"></a><a class="pred" href="format.html#format/2">format/2</a>, 
which is commonly used in the recipies used by
<a name="idx:printmessage2:1148"></a><a class="pred" href="exception.html#print_message/2">print_message/2</a> 
to emit messages.

<p>The classical definition of this predicate is equivalent to the ISO 
predicate <a name="idx:writeterm2:1149"></a><a class="pred" href="termrw.html#write_term/2">write_term/2</a> 
using the options <code>portray(true)</code> and
<code>numbervars(true)</code>. The <code>portray(true)</code> option 
allows the user to implement application-specific printing of terms 
printed during debugging to facilitate easy understanding of the output. 
See also
<a name="idx:portray1:1150"></a><a class="pred" href="termrw.html#portray/1">portray/1</a> 
and <code>library(portray_text)</code>. SWI-Prolog adds <code>quoted(true)</code> 
to (1) facilitate the copying/pasting of terms that are not affected by
<a name="idx:portray1:1151"></a><a class="pred" href="termrw.html#portray/1">portray/1</a> 
and to (2) allow numbers, atoms and strings to be more easily 
distinguished, e.g., <code>42</code>, <code>'42'</code> and <code>"42"</code>.</dd>
<dt class="pubdef"><a name="print/2"><strong>print</strong>(<var>+Stream, 
+Term</var>)</a></dt>
<dd class="defbody">
Print <var>Term</var> to <var>Stream</var>.</dd>
<dt class="pubdef"><a name="portray/1"><strong>portray</strong>(<var>+Term</var>)</a></dt>
<dd class="defbody">
A dynamic predicate, which can be defined by the user to change the 
behaviour of <a name="idx:print1:1152"></a><a class="pred" href="termrw.html#print/1">print/1</a> 
on (sub)terms. For each subterm encountered that is not a variable <a name="idx:print1:1153"></a><a class="pred" href="termrw.html#print/1">print/1</a> 
first calls <a name="idx:portray1:1154"></a><a class="pred" href="termrw.html#portray/1">portray/1</a> 
using the term as argument. For lists, only the list as a whole is given 
to <a name="idx:portray1:1155"></a><a class="pred" href="termrw.html#portray/1">portray/1</a>. 
If
<a name="idx:portray1:1156"></a><a class="pred" href="termrw.html#portray/1">portray/1</a> 
succeeds <a name="idx:print1:1157"></a><a class="pred" href="termrw.html#print/1">print/1</a> 
assumes the term has been written.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="read/1"><strong>read</strong>(<var>-Term</var>)</a></dt>
<dd class="defbody">
Read the next Prolog term from the current input stream and unify it 
with <var>Term</var>. On a syntax error <a name="idx:read1:1158"></a><a class="pred" href="termrw.html#read/1">read/1</a> 
displays an error message, attempts to skip the erroneous term and 
fails. On reaching end-of-file
<var>Term</var> is unified with the atom <code>end_of_file</code>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="read/2"><strong>read</strong>(<var>+Stream, 
-Term</var>)</a></dt>
<dd class="defbody">
Read <var>Term</var> from <var>Stream</var>.</dd>
<dt class="pubdef"><a name="read_clause/3"><strong>read_clause</strong>(<var>+Stream, 
-Term, +Options</var>)</a></dt>
<dd class="defbody">
Equivalent to <a name="idx:readterm3:1159"></a><a class="pred" href="termrw.html#read_term/3">read_term/3</a>, 
but sets options according to the current compilation context and 
optionally processes comments. Defined options:

<dl class="latex">
<dt><strong>syntax_errors</strong>(<var>+Atom</var>)</dt>
<dd class="defbody">
See <a name="idx:readterm3:1160"></a><a class="pred" href="termrw.html#read_term/3">read_term/3</a>, 
but the default is <code>dec10</code> (report and restart).</dd>
<dt><strong>term_position</strong>(<var>-TermPos</var>)</dt>
<dd class="defbody">
Same as for <a name="idx:readterm3:1161"></a><a class="pred" href="termrw.html#read_term/3">read_term/3</a>.</dd>
<dt><strong>subterm_positions</strong>(<var>-TermPos</var>)</dt>
<dd class="defbody">
Same as for <a name="idx:readterm3:1162"></a><a class="pred" href="termrw.html#read_term/3">read_term/3</a>.</dd>
<dt><strong>variable_names</strong>(<var>-Bindings</var>)</dt>
<dd class="defbody">
Same as for <a name="idx:readterm3:1163"></a><a class="pred" href="termrw.html#read_term/3">read_term/3</a>.</dd>
<dt><strong>process_comment</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
If <code>true</code> (default), call
<code>prolog:comment_hook(Comments, TermPos, Term)</code> if this 
multifile hook is defined (see prolog:comment_hook/3). This is used to 
drive PlDoc.</dd>
<dt><strong>comments</strong>(<var>-Comments</var>)</dt>
<dd class="defbody">
If provided, unify <var>Comments</var> with the comments encountered 
while reading <var>Term</var>. This option implies
<code>process_comment(false)</code>.
</dd>
</dl>

<p>The <code>singletons</code> option of <a name="idx:readterm3:1164"></a><a class="pred" href="termrw.html#read_term/3">read_term/3</a> 
is initialised from the active style-checking mode. The <code>module</code> 
option is initialised to the current compilation module (see <a name="idx:prologloadcontext2:1165"></a><a class="pred" href="consulting.html#prolog_load_context/2">prolog_load_context/2</a>).</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="read_term/2"><strong>read_term</strong>(<var>-Term, 
+Options</var>)</a></dt>
<dd class="defbody">
Read a term from the current input stream and unify the term with
<var>Term</var>. The reading is controlled by options from the list of
<var>Options</var>. If this list is empty, the behaviour is the same as 
for
<a name="idx:read1:1166"></a><a class="pred" href="termrw.html#read/1">read/1</a>. 
The options are upward compatible with Quintus Prolog. The argument 
order is according to the ISO standard. Syntax errors are always 
reported using exception-handling (see <a name="idx:catch3:1167"></a><a class="pred" href="exception.html#catch/3">catch/3</a>). 
Options:

<dl class="latex">
<dt><strong>backquoted_string</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>true</code>, read <code>`</code>...<code>`</code> to a string 
object (see
<a class="sec" href="strings.html">section 5.2</a>). The default depends 
on the Prolog flag
<a class="flag" href="flags.html#flag:back_quotes">back_quotes</a>.</dd>
<dt><strong>character_escapes</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
Defines how to read <code>\</code> escape sequences in quoted atoms. See 
the Prolog flag <a class="flag" href="flags.html#flag:character_escapes">character_escapes</a> 
in <a name="idx:currentprologflag2:1168"></a><a class="pred" href="flags.html#current_prolog_flag/2">current_prolog_flag/2</a>. 
(SWI-Prolog).</dd>
<dt><strong>comments</strong>(<var>-Comments</var>)</dt>
<dd class="defbody">
Unify <var>Comments</var> with a list of <var>Position</var>-<var>Comment</var>, 
where
<var>Position</var> is a stream position object (see <a name="idx:streampositiondata3:1169"></a><a class="pred" href="IO.html#stream_position_data/3">stream_position_data/3</a>) 
indicating the start of a comment and <var>Comment</var> is a string 
object containing the text including delimiters of a comment. It returns 
all comments from where the <a name="idx:readterm2:1170"></a><a class="pred" href="termrw.html#read_term/2">read_term/2</a> 
call started up to the end of the term read.</dd>
<dt><strong>cycles</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>true</code> (default <code>false</code>), re-instantiate 
templates as produced by the corresponding <a name="idx:writeterm2:1171"></a><a class="pred" href="termrw.html#write_term/2">write_term/2</a> 
option. Note that the default is <code>false</code> to avoid 
misinterpretation of <code>@(Template, Substutions)</code>, while the 
default of <a name="idx:writeterm2:1172"></a><a class="pred" href="termrw.html#write_term/2">write_term/2</a> 
is <code>true</code> because emitting cyclic terms without using the 
template construct produces an infinitely large term (read: it will 
generate an error after producing a huge amount of output).</dd>
<dt><strong>dotlists</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>true</code> (default <code>false</code>), read <code>.(a,[])</code> 
as a list, even if lists are internally nor constructed using the dot as 
functor. This is primarily intended to read the output from <a name="idx:writecanonical1:1173"></a><a class="pred" href="termrw.html#write_canonical/1">write_canonical/1</a> 
from other Prolog systems. See <a class="sec" href="ext-lists.html">section 
5.1</a>.</dd>
<dt><strong>double_quotes</strong>(<var>Atom</var>)</dt>
<dd class="defbody">
Defines how to read " ... " strings. See the Prolog flag
<a class="flag" href="flags.html#flag:double_quotes">double_quotes</a>. 
(SWI-Prolog).</dd>
<dt><strong>module</strong>(<var>Module</var>)</dt>
<dd class="defbody">
Specify <var>Module</var> for operators, <a class="flag" href="flags.html#flag:character_escapes">character_escapes</a> 
flag and <a class="flag" href="flags.html#flag:double_quotes">double_quotes</a> 
flag. The value of the latter two is overruled if the corresponding <a name="idx:readterm3:1174"></a><a class="pred" href="termrw.html#read_term/3">read_term/3</a> 
option is provided. If no module is specified, the current `source 
module' is used. (SWI-Prolog).</dd>
<dt><strong>quasi_quotations</strong>(<var>-List</var>)</dt>
<dd class="defbody">
If present, unify <var>List</var> with the quasi quotations (see
<a class="sec" href="quasiquotations.html">section A.28</a>) instead of 
evaluating quasi quotations. Each quasi quotation is a term <code>quasi_quotation(+Syntax, 
+Quotation, +VarDict, -Result)</code>, where <var>Syntax</var> is the 
term in
<code>{|Syntax||..|}</code>, <var>Quotation</var> is a list of character 
codes that represent the quotation, <var>VarDict</var> is a list of
<var>Name</var>=<var>Variable</var> and <var>Result</var> is a variable 
that shares with the place where the quotation must be inserted. This 
option is intended to support tools that manipulate Prolog source text.</dd>
<dt><strong>singletons</strong>(<var>Vars</var>)</dt>
<dd class="defbody">
As <code>variable_names</code>, but only reports the variables occurring 
only once in the <var>Term</var> read. Variables starting with an 
underscore (`<code>_</code>') are not included in this list. (ISO). If <var>Vars</var> 
is the constant <code>warning</code>, singleton variables are reported 
using
<a name="idx:printmessage2:1175"></a><a class="pred" href="exception.html#print_message/2">print_message/2</a>. 
The variables appear in the order they have been read.</dd>
<dt><strong>syntax_errors</strong>(<var>Atom</var>)</dt>
<dd class="defbody">
If <code>error</code> (default), throw an exception on a syntax error. 
Other values are <code>fail</code>, which causes a message to be printed 
using
<a name="idx:printmessage2:1176"></a><a class="pred" href="exception.html#print_message/2">print_message/2</a>, 
after which the predicate fails, <code>quiet</code> which causes the 
predicate to fail silently, and <code>dec10</code> which causes syntax 
errors to be printed, after which <a name="idx:readterm23:1177"></a><a class="pred" href="termrw.html#read_term/2">read_term/[2,3]</a> 
continues reading the next term. Using <code>dec10</code>, <a name="idx:readterm23:1178"></a><a class="pred" href="termrw.html#read_term/2">read_term/[2,3]</a> 
never fails. (Quintus, SICStus).</dd>
<dt><strong>subterm_positions</strong>(<var>TermPos</var>)</dt>
<dd class="defbody">
Describes the detailed layout of the term. The formats for the various 
types of terms are given below. All positions are character positions. 
If the input is related to a normal stream, these positions are relative 
to the start of the input; when reading from the terminal, they are 
relative to the start of the term.

<dl class="latex">
<dt><b><var>From</var>-<var>To</var></b></dt>
<dd class="defbody">
Used for primitive types (atoms, numbers, variables).</dd>
<dt><strong>string_position</strong>(<var><var>From</var>, <var>To</var></var>)</dt>
<dd class="defbody">
Used to indicate the position of a string enclosed in double quotes (<code>"</code>).</dd>
<dt><strong>brace_term_position</strong>(<var><var>From</var>, <var>To</var>, <var>Arg</var></var>)</dt>
<dd class="defbody">
Term of the form <code>{...}</code>, as used in DCG rules. <var>Arg</var> 
describes the argument.</dd>
<dt><strong>list_position</strong>(<var><var>From</var>, <var>To</var>, <var>Elms</var>, <var>Tail</var></var>)</dt>
<dd class="defbody">
A list. <var>Elms</var> describes the positions of the elements. If the 
list specifies the tail as <code><code>|</code></code>&lt;TailTerm&gt; , <var>Tail</var> 
is unified with the term position of the tail, otherwise with the atom <code>none</code>.</dd>
<dt><strong>term_position</strong>(<var><var>From</var>, <var>To</var>, <var>FFrom</var>, <var>FTo</var>, <var>SubPos</var></var>)</dt>
<dd class="defbody">
Used for a compound term not matching one of the above. <var>FFrom</var> 
and <var>FTo</var> describe the position of the functor. <var>SubPos</var> 
is a list, each element of which describes the term position of the 
corresponding subterm.</dd>
<dt><strong>dict_position</strong>(<var><var>From</var>, <var>To</var>, <var>TagFrom</var>, <var>TagTo</var>, <var>KeyValuePosList</var></var>)</dt>
<dd class="defbody">
Used for a dict (see <a class="sec" href="dicts.html">section 5.4</a>). 
The position of the key-value pairs is described by <var>KeyValuePosList</var>, 
which is a list of
<code>key_value_position/7</code> terms. The <code>key_value_position/7</code> 
terms appear in the order of the input. Because maps to not preserve 
ordering, the key is provided in the position description.</dd>
<dt><strong>key_value_position</strong>(<var><var>From</var>, <var>To</var>, <var>SepFrom</var>, <var>SepTo</var>, <var>Key</var>, <var>KeyPos</var>, <var>ValuePos</var></var>)</dt>
<dd class="defbody">
Used for key-value pairs in a map (see <a class="sec" href="dicts.html">section 
5.4</a>). It is similar to the <code>term_position/5</code> that would 
be created, except that the key and value positions do not need an 
intermediate list and the key is provided in <var>Key</var> to enable 
synchronisation of the file position data with the data structure.</dd>
<dt><strong>parentheses_term_position</strong>(<var><var>From</var>, <var>To</var>, <var>ContentPos</var></var>)</dt>
<dd class="defbody">
Used for terms between parentheses. This is an extension compared to the 
original Quintus specification that was considered necessary for secure 
refactoring of terms.</dd>
<dt><strong>quasi_quotation_position</strong>(<var><var>From</var>, <var>To</var>, <var>SyntaxFrom</var>, <var>SyntaxTo</var>, <var>ContentPos</var></var>)</dt>
<dd class="defbody">
Used for quasi quotations.
</dd>
</dl>

</dd>
<dt><strong>term_position</strong>(<var>Pos</var>)</dt>
<dd class="defbody">
Unifies <var>Pos</var> with the starting position of the term read. <var>Pos</var> 
is of the same format as used by <a name="idx:streamproperty2:1179"></a><a class="pred" href="IO.html#stream_property/2">stream_property/2</a>.</dd>
<dt><strong>var_prefix</strong>(<var>Bool</var>)</dt>
<dd class="defbody">
If <code>true</code>, demand variables to start with an underscore. See
<a class="sec" href="syntax.html">section 2.16.1.7</a>.</dd>
<dt><strong>variables</strong>(<var>Vars</var>)</dt>
<dd class="defbody">
Unify <var>Vars</var> with a list of variables in the term. The 
variables appear in the order they have been read. See also <a name="idx:termvariables2:1180"></a><a class="pred" href="manipterm.html#term_variables/2">term_variables/2</a>. 
(ISO).</dd>
<dt><strong>variable_names</strong>(<var>Vars</var>)</dt>
<dd class="defbody">
Unify <var>Vars</var> with a list of `<var>Name</var> = <var>Var</var>', 
where
<var>Name</var> is an atom describing the variable name and <var>Var</var> 
is a variable that shares with the corresponding variable in <var>Term</var>. 
(ISO). The variables appear in the order they have been read.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="read_term/3"><strong>read_term</strong>(<var>+Stream, 
-Term, +Options</var>)</a></dt>
<dd class="defbody">
Read term with options from <var>Stream</var>. See <a name="idx:readterm2:1181"></a><a class="pred" href="termrw.html#read_term/2">read_term/2</a>.</dd>
<dt class="pubdef"><a name="read_term_from_atom/3"><strong>read_term_from_atom</strong>(<var>+Atom, 
-Term, +Options</var>)</a></dt>
<dd class="defbody">
Use <a name="idx:readterm3:1182"></a><a class="pred" href="termrw.html#read_term/3">read_term/3</a> 
to read the next term from <var>Atom</var>. <var>Atom</var> is either an 
atom or a string object (see <a class="sec" href="strings.html">section 
5.2</a>). It is not required for <var>Atom</var> to end with a 
full-stop. This predicate supersedes <a name="idx:atomtoterm3:1183"></a><a class="pred" href="manipatom.html#atom_to_term/3">atom_to_term/3</a>.</dd>
<dt class="pubdef"><a name="read_history/6"><strong>read_history</strong>(<var>+Show, 
+Help, +Special, +Prompt, -Term, -Bindings</var>)</a></dt>
<dd class="defbody">
Similar to <a name="idx:readterm2:1184"></a><a class="pred" href="termrw.html#read_term/2">read_term/2</a> 
using the option <code>variable_names</code>, but allows for history 
substitutions. <a name="idx:readhistory6:1185"></a><a class="pred" href="termrw.html#read_history/6">read_history/6</a> 
is used by the top level to read the user's actions. <var>Show</var> is 
the command the user should type to show the saved events. <var>Help</var> 
is the command to get an overview of the capabilities. <var>Special</var> 
is a list of commands that are not saved in the history. <var>Prompt</var> 
is the first prompt given. Continuation prompts for more lines are 
determined by <a name="idx:prompt2:1186"></a><a class="pred" href="termrw.html#prompt/2">prompt/2</a>. 
A
<code>%w</code> in the prompt is substituted by the event number. See
<a class="sec" href="history.html">section 2.7</a> for available 
substitutions.

<p>SWI-Prolog calls <a name="idx:readhistory6:1187"></a><a class="pred" href="termrw.html#read_history/6">read_history/6</a> 
as follows:

<pre class="code">
read_history(h, '!h', [trace], '%w ?- ', Goal, Bindings)
</pre>

</dd>
<dt class="pubdef"><a name="prompt/2"><strong>prompt</strong>(<var>-Old, 
+New</var>)</a></dt>
<dd class="defbody">
Set prompt associated with <a name="idx:read1:1188"></a><a class="pred" href="termrw.html#read/1">read/1</a> 
and its derivatives. <var>Old</var> is first unified with the current 
prompt. On success the prompt will be set to <var>New</var> if this is 
an atom. Otherwise an error message is displayed. A prompt is printed if 
one of the read predicates is called and the cursor is at the left 
margin. It is also printed whenever a newline is given and the term has 
not been terminated. Prompts are only printed when the current input 
stream is <var>user</var>.</dd>
<dt class="pubdef"><a name="prompt1/1"><strong>prompt1</strong>(<var>+Prompt</var>)</a></dt>
<dd class="defbody">
Sets the prompt for the next line to be read. Continuation lines will be 
read using the prompt defined by <a name="idx:prompt2:1189"></a><a class="pred" href="termrw.html#prompt/2">prompt/2</a>.
</dd>
</dl>

<p></body></html>