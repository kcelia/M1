<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>SWI-Prolog 7.6.2 Reference Manual: Section 11.8</title><link rel="home" href="index.html">
<link rel="contents" href="Contents.html">
<link rel="index" href="DocIndex.html">
<link rel="summary" href="summary.html">
<link rel="previous" href="foreignxmp.html">
<link rel="next" href="runtime.html">

<style type="text/css">

/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

dt.multidef
{ background-color: #c8ffc7;
}

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #202020;
}

div.caption
{ width: 80%;
margin: auto;
text-align:center;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}

/* Lists */

dl.latex
{ margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.latex dl.latex dd.defbody
{ margin-bottom: 0.5ex;
}

/* PlDoc Tags */

dl.tags
{ font-size: 90%;
margin-left: 5ex;
margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.tags dt
{ margin-left: 0pt;
font-weight: bold;
}

dl.tags dd
{ margin-left: 3ex;
}

td.param
{ font-style: italic;
font-weight: bold;
}

/* Index */

dt.index-sep
{ font-weight: bold;
font-size: +1;
margin-top: 1ex;
}
</style>
</head>
<body style="background:white">
<div class="navigate"><a class="nav" href="index.html"><img src="home.gif" alt="Home"></a>
<a class="nav" href="Contents.html"><img src="index.gif" alt="Contents"></a>
<a class="nav" href="DocIndex.html"><img src="yellow_pages.gif" alt="Index"></a>
<a class="nav" href="summary.html"><img src="info.gif" alt="Summary"></a>
<a class="nav" href="foreignxmp.html"><img src="prev.gif" alt="Previous"></a>
<a class="nav" href="runtime.html"><img src="next.gif" alt="Next"></a>
</div>
<h2 id="sec:foreignnotes"><a name="sec:11.8"><span class="sec-nr">11.8</span> <span class="sec-title">Notes 
on Using Foreign Code</span></a></h2>

<a name="sec:foreignnotes"></a>

<p><h3 id="sec:foreign-debug"><a name="sec:11.8.1"><span class="sec-nr">11.8.1</span> <span class="sec-title">Foreign 
debugging functions</span></a></h3>

<a name="sec:foreign-debug"></a>

<p>The functions in this section are primarily intended for debugging 
foreign extensions or embedded Prolog. Violating the constraints of the 
foreign interface often leads to crashes in a subsequent garbage 
collection. If this happens, the system needs to be recompiled with the 
cflags <code>-DO_DEBUG</code>. This is normally achieved by editing
<code>src/Makefile</code> and changing the definition of <code>COFLAGS</code> 
to the value below. The <code>-gdwarf-2 -g3</code> provides detailed 
debugging information for <b>gcc</b>. If you use another C compiler you 
may need other flags.

<pre class="code">
COFLAGS=-DO_DEBUG -gdwarf-2 -g3
</pre>

<p>After recompiling the Prolog kernel all functions listed above are 
available to use from the debugger (e.g. <b>gdb</b>) or can be placed at 
critical location in your code or the system code.

<dl class="latex">
<dt class="pubdef"><a name="PL_backtrace()"><var>void</var> <strong>PL_backtrace</strong>(<var>int 
depth, int flags</var>)</a></dt>
<dd class="defbody">
Dump a Prolog backtrace to the <code>user_error</code> stream. <var>Depth</var> 
is the number of frames to dump. <var>Flags</var> is a bitwise or of the 
following constants:

<dl class="latex">
<dt><strong>PL_BT_SAFE</strong></dt>
<dd class="defbody">
(0x1) Do not try to print <em>goals</em>. Instead, just print the 
predicate name and arity. This reduces the likelyhood to crash if
<a class="func" href="foreignnotes.html#PL_backtrace()">PL_backtrace()</a> 
is called in a damaged environment.
</dd>
<dt><strong>PL_BT_USER</strong></dt>
<dd class="defbody">
(0x2) Only show `user' frames. Default is to also show frames of hidden 
built-in predicates.
</dd>
</dl>

</dd>
<dt class="pubdef"><a name="PL_backtrace_string()"><var>char *</var> <strong>PL_backtrace_string</strong>(<var>int 
depth, int flags</var>)</a></dt>
<dd class="defbody">
As <a class="func" href="foreignnotes.html#PL_backtrace()">PL_backtrace()</a>, 
but returns the stack as a string. The string uses UTF-8 encoding. The 
returned string must be freed using <a class="func" href="foreignnotes.html#PL_free()">PL_free()</a>. 
This function is was added to get stack traces from running servers 
where I/O is redirected or discarded. For example, using <b>gdb</b>, a 
stack trace is printed in the gdb console regardless of Prolog I/O 
redirection using the following command:

<pre class="code">
(gdb) printf "%s", PL_backtrace_string(25,0)
</pre>

<p>The source distribution provides the script <code>scripts/swipl-bt</code> 
that exploits <b>gdb</b> and <a class="func" href="foreignnotes.html#PL_backtrace_string()">PL_backtrace_string()</a> 
to print stack traces in various formats for a SWI-Prolog process, given 
its process id.</dd>
<dt class="pubdef"><a name="PL_check_data()"><var>int</var> <strong>PL_check_data</strong>(<var>term_t 
data</var>)</a></dt>
<dd class="defbody">
Check the consistency of the term <var>data</var>. Returns <code>TRUE</code> 
this is actually implemented in the current version and
<code>FALSE</code> otherwise. The actual implementation only exists if 
the system is compiled with the cflag <code>-DO_DEBUG</code> or
<code>-DO_MAINTENANCE</code>. This is <em>not</em> the default.</dd>
<dt class="pubdef"><a name="PL_check_stacks()"><var>int</var> <strong>PL_check_stacks</strong>(<var></var>)</a></dt>
<dd class="defbody">
Check the consistency of the runtime stacks of the calling thread. 
Returns <code>TRUE</code> this is actually implemented in the current 
version and <code>FALSE</code> otherwise. The actual implementation only 
exists if the system is compiled with the cflag <code>-DO_DEBUG</code> 
or
<code>-DO_MAINTENANCE</code>. This is <em>not</em> the default.
</dd>
</dl>

<p>The Prolog kernel sources use the macro <b>DEBUG(Topic, Code)</b>. 
These macros are disabled in the production version and must be enabled 
by recompiling the system as described above. Specific topics can be 
enabled and disabled using the predicates <a name="idx:prologdebug1:2090"></a><a class="pred" href="foreignnotes.html#prolog_debug/1">prolog_debug/1</a> 
and
<a name="idx:prolognodebug1:2091"></a><a class="pred" href="foreignnotes.html#prolog_nodebug/1">prolog_nodebug/1</a>. 
In addition, they can be activated from the commandline using 
commandline option <code>-d topics</code>, where
<var>topics</var> is a comma-separated list of debug topics to enable. 
For example, the code below adds many consistency checks and prints 
messages if the Prolog signal handler dispatches signals.

<pre class="code">
$ swipl -d chk_secure,msg_signal
</pre>

<dl class="latex">
<dt class="pubdef"><a name="prolog_debug/1"><strong>prolog_debug</strong>(<var>+Topic</var>)</a></dt>
<dt class="pubdef"><a name="prolog_nodebug/1"><strong>prolog_nodebug</strong>(<var>+Topic</var>)</a></dt>
<dd class="defbody">
Enable/disable a debug topic. <var>Topic</var> is an atom that 
identifies the desired topic. The available topics are defined in
<code>src/pl-debug.h</code>. Please search the sources to find out what 
is actually printed and when. We highlight one topic here:

<dl class="latex">
<dt><strong>chk_secure</strong>(<var>chk_secure</var>)</dt>
<dd class="defbody">
dd many expensive consistency checks to the system. This should 
typically be used when the system crashes, notably in the garbage 
collector. Garbage collection crashes are in most cases caused by 
invalid data on the Prolog stacks. This debug topic may help locating 
how the invalid data was created.
</dd>
</dl>

</dd>
</dl>

<p><h3 id="sec:foreign-malloc"><a name="sec:11.8.2"><span class="sec-nr">11.8.2</span> <span class="sec-title">Memory 
Allocation</span></a></h3>

<a name="sec:foreign-malloc"></a>

<p>SWI-Prolog's heap memory allocation is based on the <strong>malloc</strong>(3) 
library routines. SWI-Prolog provides the functions below as a wrapper 
around malloc(). Allocation errors in these functions trap SWI-Prolog's 
fatal-error handler, in which case <a class="func" href="foreignnotes.html#PL_malloc()">PL_malloc()</a> 
or <a class="func" href="foreignnotes.html#PL_realloc()">PL_realloc()</a> 
do not return.

<p>Portable applications must use <a class="func" href="foreignnotes.html#PL_free()">PL_free()</a> 
to release strings returned by <a class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</a> 
using the <code>BUF_MALLOC</code> argument. Portable applications may 
use both <a class="func" href="foreignnotes.html#PL_malloc()">PL_malloc()</a> 
and friends or malloc() and friends but should not mix these two sets of 
functions on the same memory.

<dl class="latex">
<dt class="pubdef"><a name="PL_malloc()"><var>void *</var> <strong>PL_malloc</strong>(<var>size_t 
bytes</var>)</a></dt>
<dd class="defbody">
Allocate <var>bytes</var> of memory. On failure SWI-Prolog's fatal-error 
handler is called and <a class="func" href="foreignnotes.html#PL_malloc()">PL_malloc()</a> 
does not return. Memory allocated using these functions must use <a class="func" href="foreignnotes.html#PL_realloc()">PL_realloc()</a> 
and <a class="func" href="foreignnotes.html#PL_free()">PL_free()</a> 
rather than realloc() and free().</dd>
<dt class="pubdef"><a name="PL_realloc()"><var>void *</var> <strong>PL_realloc</strong>(<var>void 
*mem, size_t size</var>)</a></dt>
<dd class="defbody">
Change the size of the allocated chunk, possibly moving it. The
<var>mem</var> argument must be obtained from a previous <a class="func" href="foreignnotes.html#PL_malloc()">PL_malloc()</a> 
or
<a class="func" href="foreignnotes.html#PL_realloc()">PL_realloc()</a> 
call.</dd>
<dt class="pubdef"><a name="PL_free()"><var>void</var> <strong>PL_free</strong>(<var>void 
*mem</var>)</a></dt>
<dd class="defbody">
Release memory. The <var>mem</var> argument must be obtained from a 
previous <a class="func" href="foreignnotes.html#PL_malloc()">PL_malloc()</a> 
or <a class="func" href="foreignnotes.html#PL_realloc()">PL_realloc()</a> 
call.
</dd>
</dl>

<p><h4 id="sec:boehm-gc"><a name="sec:11.8.2.1"><span class="sec-nr">11.8.2.1</span> <span class="sec-title">Boehm-GC 
support</span></a></h4>

<a name="sec:boehm-gc"></a>
<blockquote> This section is obsolete. Although the Boehm-GC interfaces 
still exist, it turns out that the scalability is not good enough for 
SWI-Prolog. It is unlikely that SWI-Prolog will ever switch to Boehm-GC.
</blockquote>

<p><a name="idx:BoehmGC:2092"></a>To accommodate future use of the Boehm 
garbage collector<sup class="fn">178<span class="fn-text"><a class="url" href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">http://www.hpl.hp.com/personal/Hans_Boehm/gc/</a></span></sup> 
for heap memory allocation, the interface provides the functions 
described below. Foreign extensions that wish to use the Boehm-GC 
facilities can use these wrappers. Please note that if SWI-Prolog is not 
compiled to use Boehm-GC (default), the user is responsible for calling <a class="func" href="foreignnotes.html#PL_free()">PL_free()</a> 
to reclaim memory.

<dl class="latex">
<dt class="pubdef"><a name="PL_malloc_atomic()"><var>void*</var> <strong>PL_malloc_atomic</strong>(<var>size_t 
bytes</var>)</a></dt>
<dt class="pubdef"><a name="PL_malloc_uncollectable()"><var>void*</var> <strong>PL_malloc_uncollectable</strong>(<var>size_t 
bytes</var>)</a></dt>
<dt class="pubdef"><a name="PL_malloc_atomic_uncollectable()"><var>void*</var> <strong>PL_malloc_atomic_uncollectable</strong>(<var>size_t 
bytes</var>)</a></dt>
<dd class="defbody">
If Boehm-GC is not used, these are all the same as <a class="func" href="foreignnotes.html#PL_malloc()">PL_malloc()</a>. 
With Boehm-GC, these map to the corresponding Boehm-GC functions.
<em>Atomic</em> means that the content should not be scanned for 
pointers, and <em>uncollectable</em> means that the object should never 
be garbage collected.
</dd>
<dt class="pubdef"><a name="PL_malloc_stubborn()"><var>void*</var> <strong>PL_malloc_stubborn</strong>(<var>size_t 
bytes</var>)</a></dt>
<dt class="pubdef"><a name="PL_end_stubborn_change()"><var>void</var> <strong>PL_end_stubborn_change</strong>(<var>void 
*memory</var>)</a></dt>
<dd class="defbody">
These functions allow creating objects, promising GC that the content 
will not change after <a class="func" href="foreignnotes.html#PL_end_stubborn_change()">PL_end_stubborn_change()</a>.
</dd>
</dl>

<p><h3 id="sec:foreign-compat"><a name="sec:11.8.3"><span class="sec-nr">11.8.3</span> <span class="sec-title">Compatibility 
between Prolog versions</span></a></h3>

<a name="sec:foreign-compat"></a>

<p>Great care is taken to ensure binary compatibility of foreign 
extensions between different Prolog versions. Only the much less 
frequently used stream interface has been responsible for binary 
incompatibilities.

<p><a name="idx:PLVERSION:2093"></a>Source code that relies on new 
features of the foreign interface can use the macro <code>PLVERSION</code> 
to find the version of
<code>SWI-Prolog.h</code> and <a class="func" href="foreigninclude.html#PL_query()">PL_query()</a> 
using the option
<code>PL_QUERY_VERSION</code> to find the version of the attached Prolog 
system. Both follow the same numbering schema explained with <a class="func" href="foreigninclude.html#PL_query()">PL_query()</a>.

<p><h3 id="sec:foreign-debug-and-profile"><a name="sec:11.8.4"><span class="sec-nr">11.8.4</span> <span class="sec-title">Debugging 
and profiling foreign code (valgrind)</span></a></h3>

<a name="sec:foreign-debug-and-profile"></a>

<p><a name="idx:valgrind:2094"></a><a name="idx:profilingforeigncode:2095"></a>This 
section is only relevant for Unix users on platforms supported by
http://valgrind.org/valgrind. Valgrind is an excellent binary 
instrumentation platform. Unlike many other instrumentation platforms, 
valgrind can deal with code loaded through dlopen().

<p>The <b>callgrind</b> tool can be used to profile foreign code loaded 
under SWI-Prolog. Compile the foreign library adding <strong>-g</strong> 
option to <b>gcc</b> or <b>swipl-ld</b>. By setting the environment 
variable <code>VALGRIND</code> to <code>yes</code>, SWI-Prolog will <em>not</em> 
release loaded shared objects using dlclose(). This trick is required to 
get source information on the loaded library. Without, valgrind claims 
that the shared object has no debugging information.<sup class="fn">179<span class="fn-text">Tested 
using valgrind version 3.2.3 on x64.</span></sup> Here is the complete 
sequence using <b>bash</b> as login shell:

<pre class="code">
% VALGRIND=yes valgrind --tool=callgrind pl &lt;args&gt;
&lt;prolog interaction&gt;
% kcachegrind callgrind.out.&lt;pid&gt;
</pre>

<p><h3 id="sec:foreign-name-conflicts"><a name="sec:11.8.5"><span class="sec-nr">11.8.5</span> <span class="sec-title">Name 
Conflicts in C modules</span></a></h3>

<a name="sec:foreign-name-conflicts"></a>

<p>In the current version of the system all public C functions of 
SWI-Prolog are in the symbol table. This can lead to name clashes with 
foreign code. Someday I should write a program to strip all these 
symbols from the symbol table (why does Unix not have that?). For now I 
can only suggest you give your function another name. You can do this 
using the C preprocessor. If---for example---your foreign package uses a 
function warning(), which happens to exist in SWI-Prolog as well, the 
following macro should fix the problem:

<pre class="code">
#define warning warning_
</pre>

<p>Note that shared libraries do not have this problem as the shared 
library loader will only look for symbols in the main executable for 
symbols that are not defined in the library itself.

<p><h3 id="sec:foreign-quintus-sicstus"><a name="sec:11.8.6"><span class="sec-nr">11.8.6</span> <span class="sec-title">Compatibility 
of the Foreign Interface</span></a></h3>

<a name="sec:foreign-quintus-sicstus"></a>

<p>The term reference mechanism was first used by Quintus Prolog version&nbsp;3. 
SICStus Prolog version 3 is strongly based on the Quintus interface. The 
described SWI-Prolog interface is similar to using the Quintus or 
SICStus interfaces, defining all foreign-predicate arguments of type
<code>+term</code>. SWI-Prolog explicitly uses type <code>functor_t</code>, 
while Quintus and SICStus use &lt;<var>name</var>&gt; and &lt;<var>arity</var>&gt;. 
As the names of the functions differ from Prolog to Prolog, a simple 
macro layer dealing with the names can also deal with this detail. For 
example:

<pre class="code">
#define QP_put_functor(t, n, a) \
        PL_put_functor(t, PL_new_functor(n, a))
</pre>

<p>The <code>PL_unify_*()</code> functions are lacking from the Quintus 
and SICStus interface. They can easily be emulated, or the put/unify 
approach should be used to write compatible code.

<p>The <a class="func" href="foreigninclude.html#PL_open_foreign_frame()">PL_open_foreign_frame()</a>/<a class="func" href="foreigninclude.html#PL_close_foreign_frame()">PL_close_foreign_frame()</a> 
combination is lacking from both other Prologs. SICStus has <a class="func" href="foreigntypes.html#PL_new_term_refs()">PL_new_term_refs(0)</a>, 
followed by <a class="func" href="foreigntypes.html#PL_reset_term_refs()">PL_reset_term_refs()</a>, 
that allows for discarding term references.

<p>The Prolog interface for the graphical user interface package XPCE 
shares about 90% of the code using a simple macro layer to deal with 
different naming and calling conventions of the interfaces.
</body></html>