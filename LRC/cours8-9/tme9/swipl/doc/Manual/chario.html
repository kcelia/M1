<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>SWI-Prolog 7.6.2 Reference Manual: Section 4.19</title><link rel="home" href="index.html">
<link rel="contents" href="Contents.html">
<link rel="index" href="DocIndex.html">
<link rel="summary" href="summary.html">
<link rel="previous" href="streamstat.html">
<link rel="next" href="termrw.html">

<style type="text/css">

/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

dt.multidef
{ background-color: #c8ffc7;
}

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #202020;
}

div.caption
{ width: 80%;
margin: auto;
text-align:center;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}

/* Lists */

dl.latex
{ margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.latex dl.latex dd.defbody
{ margin-bottom: 0.5ex;
}

/* PlDoc Tags */

dl.tags
{ font-size: 90%;
margin-left: 5ex;
margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.tags dt
{ margin-left: 0pt;
font-weight: bold;
}

dl.tags dd
{ margin-left: 3ex;
}

td.param
{ font-style: italic;
font-weight: bold;
}

/* Index */

dt.index-sep
{ font-weight: bold;
font-size: +1;
margin-top: 1ex;
}
</style>
</head>
<body style="background:white">
<div class="navigate"><a class="nav" href="index.html"><img src="home.gif" alt="Home"></a>
<a class="nav" href="Contents.html"><img src="index.gif" alt="Contents"></a>
<a class="nav" href="DocIndex.html"><img src="yellow_pages.gif" alt="Index"></a>
<a class="nav" href="summary.html"><img src="info.gif" alt="Summary"></a>
<a class="nav" href="streamstat.html"><img src="prev.gif" alt="Previous"></a>
<a class="nav" href="termrw.html"><img src="next.gif" alt="Next"></a>
</div>
<h2 id="sec:chario"><a name="sec:4.19"><span class="sec-nr">4.19</span> <span class="sec-title">Primitive 
character I/O</span></a></h2>

<a name="sec:chario"></a>

<p>See <a class="sec" href="chars.html">section 4.2</a> for an overview 
of supported character representations.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="nl/0"><strong>nl</strong></a></dt>
<dd class="defbody">
Write a newline character to the current output stream. On Unix systems
<a name="idx:nl0:1074"></a><a class="pred" href="chario.html#nl/0">nl/0</a> 
is equivalent to <code>put(10)</code>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="nl/1"><strong>nl</strong>(<var>+Stream</var>)</a></dt>
<dd class="defbody">
Write a newline to <var>Stream</var>.</dd>
<dt class="pubdef"><a name="put/1"><strong>put</strong>(<var>+Char</var>)</a></dt>
<dd class="defbody">
Write <var>Char</var> to the current output stream. <var>Char</var> is 
either an integer expression evaluating to a character code or an atom 
of one character. Deprecated. New code should use <a name="idx:putchar1:1075"></a><a class="pred" href="chario.html#put_char/1">put_char/1</a> 
or <a name="idx:putcode1:1076"></a><a class="pred" href="chario.html#put_code/1">put_code/1</a>.</dd>
<dt class="pubdef"><a name="put/2"><strong>put</strong>(<var>+Stream, 
+Char</var>)</a></dt>
<dd class="defbody">
Write <var>Char</var> to <var>Stream</var>. See <a name="idx:put1:1077"></a><a class="pred" href="chario.html#put/1">put/1</a> 
for details.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="put_byte/1"><strong>put_byte</strong>(<var>+Byte</var>)</a></dt>
<dd class="defbody">
Write a single byte to the output. <var>Byte</var> must be an integer 
between 0 and 255.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="put_byte/2"><strong>put_byte</strong>(<var>+Stream, 
+Byte</var>)</a></dt>
<dd class="defbody">
Write a single byte to <var>Stream</var>. <var>Byte</var> must be an 
integer between 0 and 255.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="put_char/1"><strong>put_char</strong>(<var>+Char</var>)</a></dt>
<dd class="defbody">
Write a character to the current output, obeying the encoding defined 
for the current output stream. Note that this may raise an exception if 
the encoding of the output stream cannot represent <var>Char</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="put_char/2"><strong>put_char</strong>(<var>+Stream, 
+Char</var>)</a></dt>
<dd class="defbody">
Write a character to <var>Stream</var>, obeying the encoding defined for
<var>Stream</var>. Note that this may raise an exception if the encoding 
of <var>Stream</var> cannot represent <var>Char</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="put_code/1"><strong>put_code</strong>(<var>+Code</var>)</a></dt>
<dd class="defbody">
Similar to <a name="idx:putchar1:1078"></a><a class="pred" href="chario.html#put_char/1">put_char/1</a>, 
but using a <em>character code</em>. <var>Code</var> is a non-negative 
integer. Note that this may raise an exception if the encoding of the 
output stream cannot represent <var>Code</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="put_code/2"><strong>put_code</strong>(<var>+Stream, 
+Code</var>)</a></dt>
<dd class="defbody">
Same as <a name="idx:putcode1:1079"></a><a class="pred" href="chario.html#put_code/1">put_code/1</a> 
but directing <var>Code</var> to <var>Stream</var>.</dd>
<dt class="pubdef"><a name="tab/1"><strong>tab</strong>(<var>+Amount</var>)</a></dt>
<dd class="defbody">
Write <var>Amount</var> spaces on the current output stream. <var>Amount</var> 
should be an expression that evaluates to a positive integer (see
<a class="sec" href="arith.html">section 4.27</a>).</dd>
<dt class="pubdef"><a name="tab/2"><strong>tab</strong>(<var>+Stream, 
+Amount</var>)</a></dt>
<dd class="defbody">
Write <var>Amount</var> spaces to <var>Stream</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="flush_output/0"><strong>flush_output</strong></a></dt>
<dd class="defbody">
Flush pending output on current output stream. <a name="idx:flushoutput0:1080"></a><a class="pred" href="chario.html#flush_output/0">flush_output/0</a> 
is automatically generated by <a name="idx:read1:1081"></a><a class="pred" href="termrw.html#read/1">read/1</a> 
and derivatives if the current input stream is <code>user</code> and the 
cursor is not at the left margin.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="flush_output/1"><strong>flush_output</strong>(<var>+Stream</var>)</a></dt>
<dd class="defbody">
Flush output on the specified stream. The stream must be open for 
writing.</dd>
<dt class="pubdef"><a name="ttyflush/0"><strong>ttyflush</strong></a></dt>
<dd class="defbody">
Flush pending output on stream <code>user</code>. See also <a name="idx:flushoutput01:1082"></a><a class="pred" href="chario.html#flush_output/0">flush_output/[0,1]</a>.
</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="get_byte/1"><strong>get_byte</strong>(<var>-Byte</var>)</a></dt>
<dd class="defbody">
Read the current input stream and unify the next byte with <var>Byte</var> 
(an integer between 0 and 255). <var>Byte</var> is unified with -1 on 
end of file.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="get_byte/2"><strong>get_byte</strong>(<var>+Stream, 
-Byte</var>)</a></dt>
<dd class="defbody">
Read the next byte from <var>Stream</var> and unify <var>Byte</var> with 
an integer between 0 and 255.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="get_code/1"><strong>get_code</strong>(<var>-Code</var>)</a></dt>
<dd class="defbody">
Read the current input stream and unify <var>Code</var> with the 
character code of the next character. <var>Code</var> is unified with -1 
on end of file. See also <a name="idx:getchar1:1083"></a><a class="pred" href="chario.html#get_char/1">get_char/1</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="get_code/2"><strong>get_code</strong>(<var>+Stream, 
-Code</var>)</a></dt>
<dd class="defbody">
Read the next character code from <var>Stream</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="get_char/1"><strong>get_char</strong>(<var>-Char</var>)</a></dt>
<dd class="defbody">
Read the current input stream and unify <var>Char</var> with the next 
character as a one-character atom. See also <a name="idx:atomchars2:1084"></a><a class="pred" href="manipatom.html#atom_chars/2">atom_chars/2</a>. 
On end-of-file, <var>Char</var> is unified to the atom <code>end_of_file</code>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="get_char/2"><strong>get_char</strong>(<var>+Stream, 
-Char</var>)</a></dt>
<dd class="defbody">
Unify <var>Char</var> with the next character from <var>Stream</var> as 
a one-character atom. See also <a name="idx:getchar2:1085"></a><a class="pred" href="chario.html#get_char/2">get_char/2</a>, <a name="idx:getbyte2:1086"></a><a class="pred" href="chario.html#get_byte/2">get_byte/2</a> 
and <a name="idx:getcode2:1087"></a><a class="pred" href="chario.html#get_code/2">get_code/2</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[deprecated]</span><a name="get0/1"><strong>get0</strong>(<var>-Char</var>)</a></dt>
<dd class="defbody">
Edinburgh version of the ISO <a name="idx:getcode1:1088"></a><a class="pred" href="chario.html#get_code/1">get_code/1</a> 
predicate. Note that Edinburgh Prolog didn't support wide characters and 
therefore technically speaking
<a name="idx:get01:1089"></a><a class="pred" href="chario.html#get0/1">get0/1</a> 
should have been mapped to <a name="idx:getbyte1:1090"></a><a class="pred" href="chario.html#get_byte/1">get_byte/1</a>. 
The intention of <a name="idx:get01:1091"></a><a class="pred" href="chario.html#get0/1">get0/1</a>, 
however, is to read character codes.</dd>
<dt class="pubdef"><span class="pred-tag">[deprecated]</span><a name="get0/2"><strong>get0</strong>(<var>+Stream, 
-Char</var>)</a></dt>
<dd class="defbody">
Edinburgh version of the ISO <a name="idx:getcode2:1092"></a><a class="pred" href="chario.html#get_code/2">get_code/2</a> 
predicate. See also <a name="idx:get01:1093"></a><a class="pred" href="chario.html#get0/1">get0/1</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[deprecated]</span><a name="get/1"><strong>get</strong>(<var>-Char</var>)</a></dt>
<dd class="defbody">
Read the current input stream and unify the next non-blank character 
with <var>Char</var>. <var>Char</var> is unified with -1 on end of file. 
The predicate <a name="idx:get1:1094"></a><a class="pred" href="chario.html#get/1">get/1</a> 
operates on character <em>codes</em>. See also <a name="idx:get01:1095"></a><a class="pred" href="chario.html#get0/1">get0/1</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[deprecated]</span><a name="get/2"><strong>get</strong>(<var>+Stream, 
-Char</var>)</a></dt>
<dd class="defbody">
Read the next non-blank character from <var>Stream</var>. See also
<a name="idx:get1:1096"></a><a class="pred" href="chario.html#get/1">get/1</a>, <a name="idx:get01:1097"></a><a class="pred" href="chario.html#get0/1">get0/1</a> 
and <a name="idx:get02:1098"></a><a class="pred" href="chario.html#get0/2">get0/2</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="peek_byte/1"><strong>peek_byte</strong>(<var>-Byte</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="peek_byte/2"><strong>peek_byte</strong>(<var>+Stream, 
-Byte</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="peek_code/1"><strong>peek_code</strong>(<var>-Code</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="peek_code/2"><strong>peek_code</strong>(<var>+Stream, 
-Code</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="peek_char/1"><strong>peek_char</strong>(<var>-Char</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="peek_char/2"><strong>peek_char</strong>(<var>+Stream, 
-Char</var>)</a></dt>
<dd class="defbody">
Read the next byte/code/char from the input without removing it. These 
predicates do not modify the stream's position or end-of-file status. 
These predicates require a buffered stream (see <a name="idx:setstream2:1099"></a><a class="pred" href="IO.html#set_stream/2">set_stream/2</a>) 
and raise a permission error if the stream is unbuffered or the buffer 
is too small to hold the longest multi-byte sequence that might need to 
be buffered.</dd>
<dt class="pubdef"><a name="peek_string/3"><strong>peek_string</strong>(<var>+Stream, 
+Len, -String</var>)</a></dt>
<dd class="defbody">
Read the next <var>Len</var> characters (if the stream is a text stream) 
or bytes (if the stream is binary) from Stream without removing the 
data. If <var>Len</var> is larger that the stream buffer size, the 
buffer size is increased to <var>Len</var>. <var>String</var> can be 
shorter than <var>Len</var> if the stream contains less data. This 
predicate is intended to guess the content type of data read from 
non-repositionable streams.</dd>
<dt class="pubdef"><a name="skip/1"><strong>skip</strong>(<var>+Code</var>)</a></dt>
<dd class="defbody">
Read the input until <var>Code</var> or the end of the file is 
encountered. A subsequent call to <a name="idx:getcode1:1100"></a><a class="pred" href="chario.html#get_code/1">get_code/1</a> 
will read the first character after
<var>Code</var>.</dd>
<dt class="pubdef"><a name="skip/2"><strong>skip</strong>(<var>+Stream, 
+Code</var>)</a></dt>
<dd class="defbody">
Skip input (as <a name="idx:skip1:1101"></a><a class="pred" href="chario.html#skip/1">skip/1</a>) 
on <var>Stream</var>.</dd>
<dt class="pubdef"><a name="get_single_char/1"><strong>get_single_char</strong>(<var>-Code</var>)</a></dt>
<dd class="defbody">
Get a single character from input stream `user' (regardless of the 
current input stream). Unlike <a name="idx:getcode1:1102"></a><a class="pred" href="chario.html#get_code/1">get_code/1</a>, 
this predicate does not wait for a return. The character is not echoed 
to the user's terminal. This predicate is meant for keyboard menu 
selection, etc. If SWI-Prolog was started with the <strong>-tty</strong> 
option this predicate reads an entire line of input and returns the 
first non-blank character on this line, or the character code of the 
newline (10) if the entire line consisted of blank characters.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="at_end_of_stream/0"><strong>at_end_of_stream</strong></a></dt>
<dd class="defbody">
Succeeds after the last character of the current input stream has been 
read. Also succeeds if there is no valid current input stream.</dd>
<dt class="pubdef"><span class="pred-tag">[ISO]</span><a name="at_end_of_stream/1"><strong>at_end_of_stream</strong>(<var>+Stream</var>)</a></dt>
<dd class="defbody">
Succeeds after the last character of the named stream is read, or
<var>Stream</var> is not a valid input stream. The end-of-stream test is 
only available on buffered input streams (unbuffered input streams are 
rarely used; see <a name="idx:open4:1103"></a><a class="pred" href="IO.html#open/4">open/4</a>).</dd>
<dt class="pubdef"><a name="set_end_of_stream/1"><strong>set_end_of_stream</strong>(<var>+Stream</var>)</a></dt>
<dd class="defbody">
Set the size of the file opened as <var>Stream</var> to the current file 
position. This is typically used in combination with the open-mode <code>update</code>.</dd>
<dt class="pubdef"><a name="copy_stream_data/3"><strong>copy_stream_data</strong>(<var>+StreamIn, 
+StreamOut, +Len</var>)</a></dt>
<dd class="defbody">
Copy <var>Len</var> codes from <var>StreamIn</var> to <var>StreamOut</var>. 
Note that the copy is done using the semantics of <a name="idx:getcode2:1104"></a><a class="pred" href="chario.html#get_code/2">get_code/2</a> 
and
<a name="idx:putcode2:1105"></a><a class="pred" href="chario.html#put_code/2">put_code/2</a>, 
taking care of possibly recoding that needs to take place between two 
text files. See <a class="sec" href="widechars.html">section 2.19.1</a>.</dd>
<dt class="pubdef"><a name="copy_stream_data/2"><strong>copy_stream_data</strong>(<var>+StreamIn, 
+StreamOut</var>)</a></dt>
<dd class="defbody">
Copy all (remaining) data from <var>StreamIn</var> to
<var>StreamOut</var>.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a name="fill_buffer/1"><strong>fill_buffer</strong>(<var>+Stream</var>)</a></dt>
<dd class="defbody">
Fill the <var>Stream</var>'s input buffer. Subsequent calls try to read 
more input until the buffer is completely filled. This predicate is used 
together with <a name="idx:readpendingcodes3:1106"></a><a class="pred" href="chario.html#read_pending_codes/3">read_pending_codes/3</a> 
to process input with minimal buffering.</dd>
<dt class="pubdef"><a name="read_pending_codes/3"><strong>read_pending_codes</strong>(<var>+StreamIn, 
-Codes, ?Tail</var>)</a></dt>
<dd class="defbody">
Read input pending in the input buffer of <var>StreamIn</var> and return 
it in the difference list <var>Codes</var>-<var>Tail</var>. That is, the 
available characters codes are used to create the list <var>Codes</var> 
ending in the tail <var>Tail</var>. On encountering end-of-file, both
<var>Codes</var> and <var>Tail</var> are unified with the empty list (\[]).

<p>This predicate is intended for efficient unbuffered copying and 
filtering of input coming from network connections or devices. It also 
enables the library <code>library(pure_input)</code>, which processes 
input from files and streams using a DCG.

<p>The following code fragment realises efficient non-blocking copying 
of data from an input to an output stream. The <a name="idx:atendofstream1:1107"></a><a class="pred" href="chario.html#at_end_of_stream/1">at_end_of_stream/1</a> 
call checks for end-of-stream and fills the input buffer. Note that the 
use of a <a name="idx:getcode2:1108"></a><a class="pred" href="chario.html#get_code/2">get_code/2</a> 
and <a name="idx:putcode2:1109"></a><a class="pred" href="chario.html#put_code/2">put_code/2</a> 
based loop requires a <a name="idx:flushoutput1:1110"></a><a class="pred" href="chario.html#flush_output/1">flush_output/1</a> 
call after <em>each</em> <a name="idx:putcode2:1111"></a><a class="pred" href="chario.html#put_code/2">put_code/2</a>. 
The <a name="idx:copystreamdata2:1112"></a><a class="pred" href="chario.html#copy_stream_data/2">copy_stream_data/2</a> 
does not allow for inspection of the copied data and suffers from the 
same buffering issues.

<pre class="code">
copy(In, Out) :-
        repeat,
            fill_buffer(In),
            read_pending_codes(In, Chars, Tail),
            \+ \+ ( Tail = [],
                    format(Out, '~s', [Chars]),
                    flush_output(Out)
                  ),
            (   Tail == []
            -&gt;  !
            ;   fail
            ).
</pre>

</dd>
<dt class="pubdef"><a name="read_pending_chars/3"><strong>read_pending_chars</strong>(<var>+StreamIn, 
-Chars, ?Tail</var>)</a></dt>
<dd class="defbody">
As <a name="idx:readpendingcodes3:1113"></a><a class="pred" href="chario.html#read_pending_codes/3">read_pending_codes/3</a>, 
but returns a difference list of one-character atoms.
</dd>
</dl>

<p></body></html>