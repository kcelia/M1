<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>SWI-Prolog 7.6.2 Reference Manual</title><link rel="home" href="index.html">
<link rel="contents" href="Contents.html">
<link rel="index" href="DocIndex.html">
<link rel="summary" href="summary.html">
<link rel="previous" href="portabilitystrategies.html">
<link rel="next" href="license.html">

<style type="text/css">

/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

dt.multidef
{ background-color: #c8ffc7;
}

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #202020;
}

div.caption
{ width: 80%;
margin: auto;
text-align:center;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}

/* Lists */

dl.latex
{ margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.latex dl.latex dd.defbody
{ margin-bottom: 0.5ex;
}

/* PlDoc Tags */

dl.tags
{ font-size: 90%;
margin-left: 5ex;
margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.tags dt
{ margin-left: 0pt;
font-weight: bold;
}

dl.tags dd
{ margin-left: 3ex;
}

td.param
{ font-style: italic;
font-weight: bold;
}

/* Index */

dt.index-sep
{ font-weight: bold;
font-size: +1;
margin-top: 1ex;
}
</style>
</head>
<body style="background:white">
<div class="navigate"><a class="nav" href="index.html"><img src="home.gif" alt="Home"></a>
<a class="nav" href="Contents.html"><img src="index.gif" alt="Contents"></a>
<a class="nav" href="DocIndex.html"><img src="yellow_pages.gif" alt="Index"></a>
<a class="nav" href="summary.html"><img src="info.gif" alt="Summary"></a>
<a class="nav" href="portabilitystrategies.html"><img src="prev.gif" alt="Previous"></a>
<a class="nav" href="license.html"><img src="next.gif" alt="Next"></a>
</div>
<h1 id="sec:glossary"><a name="sec:D"><span class="sec-nr">D</span> <span class="sec-title">Glossary 
of Terms</span></a></h1>

<a name="sec:glossary"></a>

<dl class="latex">
<dt><a name="gloss:anonymou"><strong>anonymous [variable]</strong></a></dt>
<dd class="defbody">
<a name="idx:anonymousvariable:2266"></a><a name="idx:variableanonymous:2267"></a>The 
variable <code>_</code> is called the <a class="gloss" href="glossary.html#gloss:anonymou">anonymous</a> 
variable. Multiple occurrences of <code>_</code> in a single <a class="gloss" href="glossary.html#gloss:term">term</a> 
are not <a class="gloss" href="glossary.html#gloss:shared">shared</a>.</dd>
<dt><a name="gloss:argument"><strong>arguments</strong></a></dt>
<dd class="defbody">
Arguments are <a class="gloss" href="glossary.html#gloss:term">terms</a> 
that appear in a <a class="gloss" href="glossary.html#gloss:compound">compound</a> <a class="gloss" href="glossary.html#gloss:term">term</a>. <var>A1</var> 
and <var>a2</var> are the first and second argument of the term
<code>myterm(A1, a2)</code>.</dd>
<dt><a name="gloss:arity"><strong>arity</strong></a></dt>
<dd class="defbody">
<a name="idx:arity:2268"></a>Argument count (= number of arguments) of a <a class="gloss" href="glossary.html#gloss:compound">compound</a> <a class="gloss" href="glossary.html#gloss:term">term</a>.</dd>
<dt><a name="gloss:assert"><strong>assert</strong></a></dt>
<dd class="defbody">
<a name="idx:assert:2269"></a>Add a <a class="gloss" href="glossary.html#gloss:clause">clause</a> 
to a <a class="gloss" href="glossary.html#gloss:predicate">predicate</a>. 
Clauses can be added at either end of the clause-list of a <a class="gloss" href="glossary.html#gloss:predicate">predicate</a>. 
See <a name="idx:asserta1:2270"></a><a class="pred" href="db.html#asserta/1">asserta/1</a> 
and <a name="idx:assertz1:2271"></a><a class="pred" href="db.html#assertz/1">assertz/1</a>.</dd>
<dt><a name="gloss:atom"><strong>atom</strong></a></dt>
<dd class="defbody">
<a name="idx:atom:2272"></a>Textual constant. Used as name for <a class="gloss" href="glossary.html#gloss:compound">compound</a> 
terms, to represent constants or text.</dd>
<dt><a name="gloss:backtracking"><strong>backtracking</strong></a></dt>
<dd class="defbody">
<a name="idx:backtracking:2273"></a>Search process used by Prolog. If a 
predicate offers multiple
<a class="gloss" href="glossary.html#gloss:clause">clauses</a> to solve 
a <a class="gloss" href="glossary.html#gloss:goal">goal</a>, they are 
tried one-by-one until one <a class="gloss" href="glossary.html#gloss:succeed">succeeds</a>. 
If a subsequent part of the proof is not satisfied with the resulting <a class="gloss" href="glossary.html#gloss:variable">variable</a> <a class="gloss" href="glossary.html#gloss:binding">binding</a>, 
it may ask for an alternative <a class="gloss" href="glossary.html#gloss:solution">solution</a> 
(= <a class="gloss" href="glossary.html#gloss:binding">binding</a> of 
the <a class="gloss" href="glossary.html#gloss:variable">variables</a>), 
causing Prolog to reject the previously chosen <a class="gloss" href="glossary.html#gloss:clause">clause</a> 
and try the next one.</dd>
<dt><a name="gloss:binding"><strong>binding [of a variable]</strong></a></dt>
<dd class="defbody">
<a name="idx:binding:2274"></a>Current value of the <a class="gloss" href="glossary.html#gloss:variable">variable</a>. 
See also <a class="gloss" href="glossary.html#gloss:backtracking">backtracking</a> 
and
<a class="gloss" href="glossary.html#gloss:query">query</a>.</dd>
<dt><a name="gloss:built-in"><strong>built-in [predicate]</strong></a></dt>
<dd class="defbody">
<a name="idx:builtinpredicate:2275"></a>Predicate that is part of the 
Prolog system. Built-in predicates cannot be redefined by the user, 
unless this is overruled using
<a name="idx:redefinesystempredicate1:2276"></a><a class="pred" href="db.html#redefine_system_predicate/1">redefine_system_predicate/1</a>.</dd>
<dt><a name="gloss:body"><strong>body</strong></a></dt>
<dd class="defbody">
<a name="idx:body:2277"></a>Part of a <a class="gloss" href="glossary.html#gloss:clause">clause</a> 
behind the <a class="gloss" href="glossary.html#gloss:neck">neck</a> 
operator (<code><code>:-</code></code>).</dd>
<dt><a name="gloss:choice-point"><strong>choice point</strong></a></dt>
<dd class="defbody">
<a name="idx:choicepoint:2278"></a>A <a class="gloss" href="glossary.html#gloss:choice-point">choice point</a> 
represents a choice in the search for a <a class="gloss" href="glossary.html#gloss:solution">solution</a>. 
Choice points are created if multiple clauses match a <a class="gloss" href="glossary.html#gloss:query">query</a> 
or using disjunction (<a class="pred" href="control.html#;/2">;/2</a>). 
On <a class="gloss" href="glossary.html#gloss:backtracking">backtracking</a>, 
the execution state of the most recent <a class="gloss" href="glossary.html#gloss:choice-point">choice point</a> 
is restored and search continues with the next alternative (i.e., next 
clause or second branch of
<a class="pred" href="control.html#;/2">;/2</a>).</dd>
<dt><a name="gloss:clause"><strong>clause</strong></a></dt>
<dd class="defbody">
<a name="idx:clause:2279"></a>`Sentence' of a Prolog program. A <a class="gloss" href="glossary.html#gloss:clause">clause</a> 
consists of a <a class="gloss" href="glossary.html#gloss:head">head</a> 
and
<a class="gloss" href="glossary.html#gloss:body">body</a> separated by 
the <a class="gloss" href="glossary.html#gloss:neck">neck</a> operator (<code><code>:-</code></code>) 
or it is a
<a class="gloss" href="glossary.html#gloss:fact">fact</a>. For example:

<pre class="code">
parent(X) :-
        father(X, _).
</pre>

<p>Expressed as ``X is a parent if X is a father of someone''. See also
<a class="gloss" href="glossary.html#gloss:variable">variable</a> and <a class="gloss" href="glossary.html#gloss:predicate">predicate</a>.</dd>
<dt><a name="gloss:compile"><strong>compile</strong></a></dt>
<dd class="defbody">
Process where a Prolog <a class="gloss" href="glossary.html#gloss:program">program</a> 
is translated to a sequence of instructions. See also <a class="gloss" href="glossary.html#gloss:interpreted">interpreted</a>. 
SWI-Prolog always compiles your program before executing it.</dd>
<dt><a name="gloss:compound"><strong>compound [term]</strong></a></dt>
<dd class="defbody">
<a name="idx:compound:2280"></a>Also called <a class="gloss" href="glossary.html#gloss:structure">structure</a>. 
It consists of a name followed by <var>N</var>
<a class="gloss" href="glossary.html#gloss:argument">arguments</a>, each 
of which are <a class="gloss" href="glossary.html#gloss:term">terms</a>. <var>N</var> 
is called the
<a class="gloss" href="glossary.html#gloss:arity">arity</a> of the term.</dd>
<dt><a name="gloss:context-module"><strong>context module</strong></a></dt>
<dd class="defbody">
<a name="idx:contextmodule:2281"></a><a name="idx:modulecontex:2282"></a>If 
a <a class="gloss" href="glossary.html#gloss:term">term</a> is referring 
to a <a class="gloss" href="glossary.html#gloss:predicate">predicate</a> 
in a <a class="gloss" href="glossary.html#gloss:module">module</a>, the
<a class="gloss" href="glossary.html#gloss:context-module">context module</a> 
is used to find the target module. The context module of a <a class="gloss" href="glossary.html#gloss:goal">goal</a> 
is the module in which the <a class="gloss" href="glossary.html#gloss:predicate">predicate</a> 
is defined, unless this <a class="gloss" href="glossary.html#gloss:predicate">predicate</a> 
is <a class="gloss" href="glossary.html#gloss:module-transparent">module transparent</a>, 
in which case the <a class="gloss" href="glossary.html#gloss:context-module">context module</a> 
is inherited from the parent
<a class="gloss" href="glossary.html#gloss:goal">goal</a>. See also <a name="idx:moduletransparent1:2283"></a><a class="pred" href="ctxmodule.html#module_transparent/1">module_transparent/1</a> 
and <a class="gloss" href="glossary.html#gloss:meta-predicate">meta-predicate</a>.</dd>
<dt><a name="gloss:dcg"><strong>dcg</strong></a></dt>
<dd class="defbody">
<a name="idx:dcg:2284"></a>Abbreviation for <b>Definite Clause Grammar</b>.</dd>
<dt><a name="gloss:det"><strong>det [determinism]</strong></a></dt>
<dd class="defbody">
<a name="idx:det:2285"></a>Short for <a class="gloss" href="glossary.html#gloss:deterministic">deterministic</a>.</dd>
<dt><a name="gloss:determinism"><strong>determinism</strong></a></dt>
<dd class="defbody">
<a name="idx:determinism:2286"></a>How many solutions a <a class="gloss" href="glossary.html#gloss:goal">goal</a> 
can provide. Values are `nondet' (zero to infinite), `multi' (one to 
infinite), `det' (exactly one) and `semidet' (zero or one).</dd>
<dt><a name="gloss:deterministic"><strong>deterministic</strong></a></dt>
<dd class="defbody">
<a name="idx:deterministic:2287"></a>A <a class="gloss" href="glossary.html#gloss:predicate">predicate</a> 
is <a class="gloss" href="glossary.html#gloss:deterministic">deterministic</a> 
if it succeeds exactly one time without leaving a <a class="gloss" href="glossary.html#gloss:choice-point">choice point</a>.</dd>
<dt><a name="gloss:dynamic"><strong>dynamic [predicate]</strong></a></dt>
<dd class="defbody">
<a name="idx:dynamicpredicate:2288"></a><a name="idx:predicatedynamic:2289"></a>A <a class="gloss" href="glossary.html#gloss:dynamic">dynamic</a> 
predicate is a predicate to which <a class="gloss" href="glossary.html#gloss:clause">clauses</a> 
may be
<a class="gloss" href="glossary.html#gloss:assert">assert</a>ed and from 
which <a class="gloss" href="glossary.html#gloss:clause">clauses</a> may 
be <a class="gloss" href="glossary.html#gloss:retract">retract</a>ed 
while the program is running. See also <a class="gloss" href="glossary.html#gloss:update-view">update view</a>.</dd>
<dt><a name="gloss:exported"><strong>exported [predicate]</strong></a></dt>
<dd class="defbody">
<a name="idx:exportedpredicate:2290"></a><a name="idx:predicateexported:2291"></a>A <a class="gloss" href="glossary.html#gloss:predicate">predicate</a> 
is said to be <a class="gloss" href="glossary.html#gloss:exported">exported</a> 
from a <a class="gloss" href="glossary.html#gloss:module">module</a> if 
it appears in the <a class="gloss" href="glossary.html#gloss:public-list">public list</a>. 
This implies that the predicate can be <a class="gloss" href="glossary.html#gloss:imported">imported</a> 
into another module to make it visible there. See also <a name="idx:usemodule12:2292"></a><a class="pred" href="import.html#use_module/1">use_module/[1,2]</a>.</dd>
<dt><a name="gloss:fact"><strong>fact</strong></a></dt>
<dd class="defbody">
<a name="idx:fact:2293"></a><a class="gloss" href="glossary.html#gloss:clause">Clause</a> 
without a <a class="gloss" href="glossary.html#gloss:body">body</a>. 
This is called a fact because, interpreted as logic, there is no 
condition to be satisfied. The example below states <code>john</code> is 
a person.

<pre class="code">
person(john).
</pre>

</dd>
<dt><a name="gloss:fail"><strong>fail</strong></a></dt>
<dd class="defbody">
A <a class="gloss" href="glossary.html#gloss:goal">goal</a> is said to 
haved failed if it could not be <a class="gloss" href="glossary.html#gloss:prove">proven</a>.</dd>
<dt><a name="gloss:float"><strong>float</strong></a></dt>
<dd class="defbody">
Computer's crippled representation of a real number. Represented as 
`IEEE double'.</dd>
<dt><a name="gloss:foreign"><strong>foreign</strong></a></dt>
<dd class="defbody">
Computer code expressed in languages other than Prolog. SWI-Prolog can 
only cooperate directly with the C and C++ computer languages.</dd>
<dt><a name="gloss:functor"><strong>functor</strong></a></dt>
<dd class="defbody">
<a name="idx:functor:2294"></a>Combination of name and <a class="gloss" href="glossary.html#gloss:arity">arity</a> 
of a <a class="gloss" href="glossary.html#gloss:compound">compound</a> 
term. The term
<code>foo(a, b, c)</code> is said to be a term belonging to the functor 
foo/3 . foo/0 is used to refer to the <a class="gloss" href="glossary.html#gloss:atom">atom</a>
<code>foo</code>.</dd>
<dt><a name="gloss:goal"><strong>goal</strong></a></dt>
<dd class="defbody">
<a name="idx:goal:2295"></a><a name="idx:query:2296"></a>Question stated 
to the Prolog engine. A <a class="gloss" href="glossary.html#gloss:goal">goal</a> 
is either an <a class="gloss" href="glossary.html#gloss:atom">atom</a> 
or a <a class="gloss" href="glossary.html#gloss:compound">compound</a> 
term. A <a class="gloss" href="glossary.html#gloss:goal">goal</a> either 
succeeds, in which case the
<a class="gloss" href="glossary.html#gloss:variable">variables</a> in 
the <a class="gloss" href="glossary.html#gloss:compound">compound</a> 
terms have a <a class="gloss" href="glossary.html#gloss:binding">binding</a>, 
or it <a class="gloss" href="glossary.html#gloss:fail">fails</a> if 
Prolog fails to prove it.</dd>
<dt><a name="gloss:hashing"><strong>hashing</strong></a></dt>
<dd class="defbody">
<a name="idx:hashing:2297"></a><a class="gloss" href="glossary.html#gloss:indexing">Indexing</a> 
technique used for quick lookup.</dd>
<dt><a name="gloss:head"><strong>head</strong></a></dt>
<dd class="defbody">
<a name="idx:head:2298"></a>Part of a <a class="gloss" href="glossary.html#gloss:clause">clause</a> 
before the <a class="gloss" href="glossary.html#gloss:neck">neck</a> 
operator (<code><code>:-</code></code>). This is an <a class="gloss" href="glossary.html#gloss:atom">atom</a> 
or <a class="gloss" href="glossary.html#gloss:compound">compound</a> 
term.</dd>
<dt><a name="gloss:imported"><strong>imported [predicate]</strong></a></dt>
<dd class="defbody">
<a name="idx:importedpredicate:2299"></a><a name="idx:predicateimported:2300"></a>A <a class="gloss" href="glossary.html#gloss:predicate">predicate</a> 
is said to be <a class="gloss" href="glossary.html#gloss:imported">imported</a> 
into a <a class="gloss" href="glossary.html#gloss:module">module</a> if 
it is defined in another <a class="gloss" href="glossary.html#gloss:module">module</a> 
and made available in this <a class="gloss" href="glossary.html#gloss:module">module</a>. 
See also <a class="sec" href="modules.html">chapter 6</a>.</dd>
<dt><a name="gloss:indexing"><strong>indexing</strong></a></dt>
<dd class="defbody">
<a name="idx:indexing:2301"></a>Indexing is a technique used to quickly 
select candidate <a class="gloss" href="glossary.html#gloss:clause">clauses</a> 
of a <a class="gloss" href="glossary.html#gloss:predicate">predicate</a> 
for a specific <a class="gloss" href="glossary.html#gloss:goal">goal</a>. 
In most Prolog systems, indexing is done (only) on the first <a class="gloss" href="glossary.html#gloss:argument">argument</a> 
of the <a class="gloss" href="glossary.html#gloss:head">head</a>. If 
this argument is instantiated to an <a class="gloss" href="glossary.html#gloss:atom">atom</a>, <a class="gloss" href="glossary.html#gloss:integer">integer</a>, <a class="gloss" href="glossary.html#gloss:float">float</a> 
or
<a class="gloss" href="glossary.html#gloss:compound">compound</a> term 
with <a class="gloss" href="glossary.html#gloss:functor">functor</a>, <a class="gloss" href="glossary.html#gloss:hashing">hashing</a> 
is used to quickly select all <a class="gloss" href="glossary.html#gloss:clause">clauses</a> 
where the first argument may <a class="gloss" href="glossary.html#gloss:unify">unify</a> 
with the first argument of the <a class="gloss" href="glossary.html#gloss:goal">goal</a>. 
SWI-Prolog supports just-in-time and multi-argument indexing. See <a class="sec" href="jitindex.html">section 
2.18</a>.</dd>
<dt><a name="gloss:integer"><strong>integer</strong></a></dt>
<dd class="defbody">
<a name="idx:integer:2302"></a>Whole number. On all implementations of 
SWI-Prolog integers are at least 64-bit signed values. When linked to 
the GNU GMP library, integer arithmetic is unbounded. See also <a name="idx:currentprologflag2:2303"></a><a class="pred" href="flags.html#current_prolog_flag/2">current_prolog_flag/2</a>, 
flags <a class="flag" href="flags.html#flag:bounded">bounded</a>, <a class="flag" href="flags.html#flag:max_integer">max_integer</a> 
and <a class="flag" href="flags.html#flag:min_integer">min_integer</a>.</dd>
<dt><a name="gloss:interpreted"><strong>interpreted</strong></a></dt>
<dd class="defbody">
<a name="idx:interpreted:2304"></a>As opposed to <a class="gloss" href="glossary.html#gloss:compile">compiled</a>, 
interpreted means the Prolog system attempts to prove a <a class="gloss" href="glossary.html#gloss:goal">goal</a> 
by directly reading the <a class="gloss" href="glossary.html#gloss:clause">clauses</a> 
rather than executing instructions from an (abstract) instruction set 
that is not or only indirectly related to Prolog.</dd>
<dt><a name="gloss:instantiation"><strong>instantiation [of an argument]</strong></a></dt>
<dd class="defbody">
<a name="idx:instantiation:2305"></a>To what extend a term is bound to a 
value. Typical levels are `unbound' (a <a class="gloss" href="glossary.html#gloss:variable">variable</a>), 
`ground' (term without variables) or `partially bound' (term with 
embedded variables).</dd>
<dt><a name="gloss:meta-predicate"><strong>meta-predicate</strong></a></dt>
<dd class="defbody">
<a name="idx:metapredicate:2306"></a>A <a class="gloss" href="glossary.html#gloss:predicate">predicate</a> 
that reasons about other <a class="gloss" href="glossary.html#gloss:predicate">predicates</a>, 
either by calling them, (re)defining them or querying <a class="gloss" href="glossary.html#gloss:property">properties</a>.</dd>
<dt><a name="gloss:mode"><strong>mode [declaration]</strong></a></dt>
<dd class="defbody">
<a name="idx:mode:2307"></a>Declaration of an argument <a class="gloss" href="glossary.html#gloss:instantiation">instantiation</a> 
pattern for a
<a class="gloss" href="glossary.html#gloss:predicate">predicate</a>, 
often accompanied with a <a class="gloss" href="glossary.html#gloss:determinism">determinism</a>.</dd>
<dt><a name="gloss:module"><strong>module</strong></a></dt>
<dd class="defbody">
<a name="idx:module:2308"></a>Collection of predicates. Each module 
defines a name-space for predicates. <a class="gloss" href="glossary.html#gloss:built-in">built-in</a> 
predicates are accessible from all modules. Predicates can be published 
(<a class="gloss" href="glossary.html#gloss:exported">exported</a>) and <a class="gloss" href="glossary.html#gloss:imported">imported</a> 
to make their definition available to other modules.</dd>
<dt><a name="gloss:module-transparent"><strong>module transparent [predicate]</strong></a></dt>
<dd class="defbody">
<a name="idx:moduletransparent:2309"></a><a name="idx:transparent:2310"></a>A <a class="gloss" href="glossary.html#gloss:predicate">predicate</a> 
that does not change the <a class="gloss" href="glossary.html#gloss:context-module">context module</a>. 
Sometimes also called a <a class="gloss" href="glossary.html#gloss:meta-predicate">meta-predicate</a>.</dd>
<dt><a name="gloss:multi"><strong>multi [determinism]</strong></a></dt>
<dd class="defbody">
<a name="idx:multi:2311"></a>A <a class="gloss" href="glossary.html#gloss:predicate">predicate</a> 
is said to have <a class="gloss" href="glossary.html#gloss:determinism">determinism</a> 
multi if it generates at
<em>least</em> one answer.</dd>
<dt><a name="gloss:multifile"><strong>multifile [predicate]</strong></a></dt>
<dd class="defbody">
Predicate for which the definition is distributed over multiple source 
files. See <a name="idx:multifile1:2312"></a><a class="pred" href="dynamic.html#multifile/1">multifile/1</a>.</dd>
<dt><a name="gloss:neck"><strong>neck</strong></a></dt>
<dd class="defbody">
<a name="idx:neck:2313"></a>Operator (<code><code>:-</code></code>) 
separating <a class="gloss" href="glossary.html#gloss:head">head</a> 
from <a class="gloss" href="glossary.html#gloss:body">body</a> in a <a class="gloss" href="glossary.html#gloss:clause">clause</a>.</dd>
<dt><a name="gloss:nondet"><strong>nondet</strong></a></dt>
<dd class="defbody">
<a name="idx:nondet:2314"></a>Short for <a class="gloss" href="glossary.html#gloss:non-deterministic">non deterministic</a>.</dd>
<dt><a name="gloss:non-deterministic"><strong>non deterministic</strong></a></dt>
<dd class="defbody">
<a name="idx:nondeterministic:2315"></a>A <a class="gloss" href="glossary.html#gloss:non-deterministic">non deterministic</a> 
predicate is a predicate that mail fail or succeed any number of times.</dd>
<dt><a name="gloss:operator"><strong>operator</strong></a></dt>
<dd class="defbody">
<a name="idx:operator:2316"></a>Symbol (<a class="gloss" href="glossary.html#gloss:atom">atom</a>) 
that may be placed before its <a class="gloss" href="glossary.html#gloss:operand">operand</a> 
(prefix), after its <a class="gloss" href="glossary.html#gloss:operand">operand</a> 
(postfix) or between its two <a class="gloss" href="glossary.html#gloss:operand">operands</a> 
(infix).

<p>In Prolog, the expression <code>a+b</code> is exactly the same as the 
canonical term <code>+(a,b)</code>.</dd>
<dt><a name="gloss:operand"><strong>operand</strong></a></dt>
<dd class="defbody">
<a name="idx:operand:2317"></a><a class="gloss" href="glossary.html#gloss:argument">Argument</a> 
of an <a class="gloss" href="glossary.html#gloss:operator">operator</a>.</dd>
<dt><a name="gloss:precedence"><strong>precedence</strong></a></dt>
<dd class="defbody">
<a name="idx:precedence:2318"></a>The <a class="gloss" href="glossary.html#gloss:priority">priority</a> 
of an <a class="gloss" href="glossary.html#gloss:operator">operator</a>. 
Operator precedence is used to interpret <code>a+b*c</code> as <code>+(a, *(b,c))</code>.</dd>
<dt><a name="gloss:predicate"><strong>predicate</strong></a></dt>
<dd class="defbody">
<a name="idx:predicate:2319"></a>Collection of <a class="gloss" href="glossary.html#gloss:clause">clauses</a> 
with the same <a class="gloss" href="glossary.html#gloss:functor">functor</a> 
(name/<a class="gloss" href="glossary.html#gloss:arity">arity</a>). If a <a class="gloss" href="glossary.html#gloss:goal">goal</a> 
is proved, the system looks for a <a class="gloss" href="glossary.html#gloss:predicate">predicate</a> 
with the same functor, then uses <a class="gloss" href="glossary.html#gloss:indexing">indexing</a> 
to select candidate <a class="gloss" href="glossary.html#gloss:clause">clauses</a> 
and then tries these <a class="gloss" href="glossary.html#gloss:clause">clauses</a> 
one-by-one. See also <a class="gloss" href="glossary.html#gloss:backtracking">backtracking</a>.</dd>
<dt><a name="gloss:predicate-indicator"><strong>predicate indicator</strong></a></dt>
<dd class="defbody">
<a name="idx:predicateindicator:2320"></a>Term of the form Name/Arity 
(traditional) or Name//Arity (ISO DCG proposal), where Name is an atom 
and Arity a non-negative integer. It acts as an <em>indicator</em> (or 
reference) to a predicate or
<a class="gloss" href="glossary.html#gloss:dcg">DCG</a> rule.</dd>
<dt><a name="gloss:priority"><strong>priority</strong></a></dt>
<dd class="defbody">
<a name="idx:priority:2321"></a>In the context of <a class="gloss" href="glossary.html#gloss:operator">operators</a> 
a synonym for <a class="gloss" href="glossary.html#gloss:precedence">precedence</a>.</dd>
<dt><a name="gloss:program"><strong>program</strong></a></dt>
<dd class="defbody">
<a name="idx:program:2322"></a>Collection of <a class="gloss" href="glossary.html#gloss:predicate">predicates</a>.</dd>
<dt><a name="gloss:property"><strong>property</strong></a></dt>
<dd class="defbody">
<a name="idx:property:2323"></a>Attribute of an object. SWI-Prolog 
defines various <em>*_property</em> predicates to query the status of 
predicates, clauses. etc.</dd>
<dt><a name="gloss:prove"><strong>prove</strong></a></dt>
<dd class="defbody">
<a name="idx:prove:2324"></a>Process where Prolog attempts to prove a <a class="gloss" href="glossary.html#gloss:query">query</a> 
using the available
<a class="gloss" href="glossary.html#gloss:predicate">predicates</a>.</dd>
<dt><a name="gloss:public-list"><strong>public list</strong></a></dt>
<dd class="defbody">
<a name="idx:publiclist:2325"></a>List of <a class="gloss" href="glossary.html#gloss:predicate">predicates</a> 
exported from a <a class="gloss" href="glossary.html#gloss:module">module</a>.</dd>
<dt><a name="gloss:query"><strong>query</strong></a></dt>
<dd class="defbody">
See <a class="gloss" href="glossary.html#gloss:goal">goal</a>.</dd>
<dt><a name="gloss:retract"><strong>retract</strong></a></dt>
<dd class="defbody">
<a name="idx:retract:2326"></a>Remove a <a class="gloss" href="glossary.html#gloss:clause">clause</a> 
from a <a class="gloss" href="glossary.html#gloss:predicate">predicate</a>. 
See also <a class="gloss" href="glossary.html#gloss:dynamic">dynamic</a>,
<a class="gloss" href="glossary.html#gloss:update-view">update view</a> 
and <a class="gloss" href="glossary.html#gloss:assert">assert</a>.</dd>
<dt><a name="gloss:semidet"><strong>semidet</strong></a></dt>
<dd class="defbody">
<a name="idx:semidet:2327"></a>Shorthand for </dd>
<dt><a name="gloss:semi-deterministic"><strong>semi deterministic</strong></a></dt>
<dd class="defbody">
.</dd>
<dt><a name="gloss:semi-deterministic"><strong>semi deterministic</strong></a></dt>
<dd class="defbody">
<a name="idx:semideterministic:2328"></a>A <a class="gloss" href="glossary.html#gloss:predicate">predicate</a> 
that is <a class="gloss" href="glossary.html#gloss:semi-deterministic">semi deterministic</a> 
either fails or succeeds exactly once without a <a class="gloss" href="glossary.html#gloss:choice-point">choice point</a>. 
See also
<a class="gloss" href="glossary.html#gloss:deterministic">deterministic</a>.</dd>
<dt><a name="gloss:shared"><strong>shared</strong></a></dt>
<dd class="defbody">
<a name="idx:shared:2329"></a>Two <a class="gloss" href="glossary.html#gloss:variable">variables</a> 
are called <a class="gloss" href="glossary.html#gloss:shared">shared</a> 
after they are <a class="gloss" href="glossary.html#gloss:unify">unified</a>. 
This implies if either of them is <a class="gloss" href="glossary.html#gloss:binding">bound</a>, 
the other is bound to the same value:

<pre class="code">
?- A = B, A = a.
A = B, B = a.
</pre>

</dd>
<dt><a name="gloss:singleton"><strong>singleton [variable]</strong></a></dt>
<dd class="defbody">
<a name="idx:singleton:2330"></a><a class="gloss" href="glossary.html#gloss:variable">Variable</a> 
appearing only one time in a <a class="gloss" href="glossary.html#gloss:clause">clause</a>. 
SWI-Prolog normally warns for this to avoid you making spelling 
mistakes. If a variable appears on purpose only once in a clause, write 
it as <code>_</code> (see <a class="gloss" href="glossary.html#gloss:anonymou">anonymous</a>). 
Rules for naming a variable and avoiding a warning are given in <a class="sec" href="syntax.html">section 
2.16.1.9</a>.</dd>
<dt><a name="gloss:solution"><strong>solution</strong></a></dt>
<dd class="defbody">
<a name="idx:solution:2331"></a><a class="gloss" href="glossary.html#gloss:binding">Bindings</a> 
resulting from a successfully <a class="gloss" href="glossary.html#gloss:prove">prove</a>n <a class="gloss" href="glossary.html#gloss:goal">goal</a>.</dd>
<dt><a name="gloss:structure"><strong>structure</strong></a></dt>
<dd class="defbody">
<a name="idx:structure:2332"></a>Synonym for <a class="gloss" href="glossary.html#gloss:compound">compound</a> 
term.</dd>
<dt><a name="gloss:string"><strong>string</strong></a></dt>
<dd class="defbody">
Used for the following representations of text: a packed array (see <a class="sec" href="strings.html">section 
5.2</a>, SWI-Prolog specific), a list of character codes or a list of 
one-character <a class="gloss" href="glossary.html#gloss:atom">atoms</a>.</dd>
<dt><a name="gloss:succeed"><strong>succeed</strong></a></dt>
<dd class="defbody">
<a name="idx:succeed:2333"></a>A <a class="gloss" href="glossary.html#gloss:goal">goal</a> 
is said to have <a class="gloss" href="glossary.html#gloss:succeed">succeeded</a> 
if it has been <a class="gloss" href="glossary.html#gloss:prove">proven</a>.</dd>
<dt><a name="gloss:term"><strong>term</strong></a></dt>
<dd class="defbody">
<a name="idx:term:2334"></a>Value in Prolog. A <a class="gloss" href="glossary.html#gloss:term">term</a> 
is either a <a class="gloss" href="glossary.html#gloss:variable">variable</a>, <a class="gloss" href="glossary.html#gloss:atom">atom</a>, <a class="gloss" href="glossary.html#gloss:integer">integer</a>,
<a class="gloss" href="glossary.html#gloss:float">float</a> or <a class="gloss" href="glossary.html#gloss:compound">compound</a> 
term. In addition, SWI-Prolog also defines the type <a class="gloss" href="glossary.html#gloss:string">string</a>.</dd>
<dt><a name="gloss:transparent"><strong>transparent</strong></a></dt>
<dd class="defbody">
See <a class="gloss" href="glossary.html#gloss:module-transparent">module transparent</a>.</dd>
<dt><a name="gloss:unify"><strong>unify</strong></a></dt>
<dd class="defbody">
<a name="idx:unify:2335"></a>Prolog process to make two terms equal by 
assigning variables in one term to values at the corresponding location 
of the other term. For example:

<pre class="code">
?- foo(a, B) = foo(A, b).
A = a,
B = b.
</pre>

<p>Unlike assignment (which does not exist in Prolog), unification is 
not directed.</dd>
<dt><a name="gloss:update-view"><strong>update view</strong></a></dt>
<dd class="defbody">
<a name="idx:updateview:2336"></a><a name="idx:viewupdate:2337"></a>How 
Prolog behaves when a <a class="gloss" href="glossary.html#gloss:dynamic">dynamic</a> <a class="gloss" href="glossary.html#gloss:predicate">predicate</a> 
is changed while it is running. There are two models. In most older 
Prolog systems the change becomes immediately visible to the <a class="gloss" href="glossary.html#gloss:goal">goal</a>, 
in modern systems including SWI-Prolog, the running <a class="gloss" href="glossary.html#gloss:goal">goal</a> 
is not affected. Only new <a class="gloss" href="glossary.html#gloss:goal">goals</a> 
`see' the new definition.</dd>
<dt><a name="gloss:variable"><strong>variable</strong></a></dt>
<dd class="defbody">
<a name="idx:variable:2338"></a>A Prolog variable is a value that `is 
not yet bound'. After <a class="gloss" href="glossary.html#gloss:binding">binding</a> 
a variable, it cannot be modified. <a class="gloss" href="glossary.html#gloss:backtracking">Backtracking</a> 
to a point in the execution before the variable was bound will turn it 
back into a variable:

<pre class="code">
?- A = b, A = c.
false.

?- (A = b; true; A = c).
A = b ;
true ;
A = c .
</pre>

<p>See also <a class="gloss" href="glossary.html#gloss:unify">unify</a>.

<p></dd>
</dl>

</body></html>